// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: chaincode/auth/common/reference.proto

package common

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ReferenceRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReferenceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceRequestMultiError, or nil if none found.
func (m *ReferenceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetReference()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReferenceRequestValidationError{
					field:  "Reference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReferenceRequestValidationError{
					field:  "Reference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReference()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReferenceRequestValidationError{
				field:  "Reference",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReferenceRequestMultiError(errors)
	}

	return nil
}

// ReferenceRequestMultiError is an error wrapping multiple validation errors
// returned by ReferenceRequest.ValidateAll() if the designated constraints
// aren't met.
type ReferenceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceRequestMultiError) AllErrors() []error { return m }

// ReferenceRequestValidationError is the validation error returned by
// ReferenceRequest.Validate if the designated constraints aren't met.
type ReferenceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceRequestValidationError) ErrorName() string { return "ReferenceRequestValidationError" }

// Error satisfies the builtin error interface
func (e ReferenceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceRequestValidationError{}

// Validate checks the field values on ReferenceResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReferenceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceResponseMultiError, or nil if none found.
func (m *ReferenceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Exists

	if all {
		switch v := interface{}(m.GetReference()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReferenceResponseValidationError{
					field:  "Reference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReferenceResponseValidationError{
					field:  "Reference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReference()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReferenceResponseValidationError{
				field:  "Reference",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReferenceResponseMultiError(errors)
	}

	return nil
}

// ReferenceResponseMultiError is an error wrapping multiple validation errors
// returned by ReferenceResponse.ValidateAll() if the designated constraints
// aren't met.
type ReferenceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceResponseMultiError) AllErrors() []error { return m }

// ReferenceResponseValidationError is the validation error returned by
// ReferenceResponse.Validate if the designated constraints aren't met.
type ReferenceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceResponseValidationError) ErrorName() string {
	return "ReferenceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReferenceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceResponseValidationError{}

// Validate checks the field values on ReferenceByCollectionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReferenceByCollectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceByCollectionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceByCollectionRequestMultiError, or nil if none found.
func (m *ReferenceByCollectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceByCollectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	// no validation rules for Limit

	// no validation rules for CollectionId

	if len(errors) > 0 {
		return ReferenceByCollectionRequestMultiError(errors)
	}

	return nil
}

// ReferenceByCollectionRequestMultiError is an error wrapping multiple
// validation errors returned by ReferenceByCollectionRequest.ValidateAll() if
// the designated constraints aren't met.
type ReferenceByCollectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceByCollectionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceByCollectionRequestMultiError) AllErrors() []error { return m }

// ReferenceByCollectionRequestValidationError is the validation error returned
// by ReferenceByCollectionRequest.Validate if the designated constraints
// aren't met.
type ReferenceByCollectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceByCollectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceByCollectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceByCollectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceByCollectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceByCollectionRequestValidationError) ErrorName() string {
	return "ReferenceByCollectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReferenceByCollectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceByCollectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceByCollectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceByCollectionRequestValidationError{}

// Validate checks the field values on ReferenceByCollectionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReferenceByCollectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceByCollectionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ReferenceByCollectionResponseMultiError, or nil if none found.
func (m *ReferenceByCollectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceByCollectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	for idx, item := range m.GetReferences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReferenceByCollectionResponseValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReferenceByCollectionResponseValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReferenceByCollectionResponseValidationError{
					field:  fmt.Sprintf("References[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReferenceByCollectionResponseMultiError(errors)
	}

	return nil
}

// ReferenceByCollectionResponseMultiError is an error wrapping multiple
// validation errors returned by ReferenceByCollectionResponse.ValidateAll()
// if the designated constraints aren't met.
type ReferenceByCollectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceByCollectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceByCollectionResponseMultiError) AllErrors() []error { return m }

// ReferenceByCollectionResponseValidationError is the validation error
// returned by ReferenceByCollectionResponse.Validate if the designated
// constraints aren't met.
type ReferenceByCollectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceByCollectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceByCollectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceByCollectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceByCollectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceByCollectionResponseValidationError) ErrorName() string {
	return "ReferenceByCollectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReferenceByCollectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceByCollectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceByCollectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceByCollectionResponseValidationError{}

// Validate checks the field values on ReferenceByPartialKeyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReferenceByPartialKeyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceByPartialKeyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceByPartialKeyRequestMultiError, or nil if none found.
func (m *ReferenceByPartialKeyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceByPartialKeyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	// no validation rules for Limit

	if all {
		switch v := interface{}(m.GetReference()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReferenceByPartialKeyRequestValidationError{
					field:  "Reference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReferenceByPartialKeyRequestValidationError{
					field:  "Reference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReference()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReferenceByPartialKeyRequestValidationError{
				field:  "Reference",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReferenceByPartialKeyRequestMultiError(errors)
	}

	return nil
}

// ReferenceByPartialKeyRequestMultiError is an error wrapping multiple
// validation errors returned by ReferenceByPartialKeyRequest.ValidateAll() if
// the designated constraints aren't met.
type ReferenceByPartialKeyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceByPartialKeyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceByPartialKeyRequestMultiError) AllErrors() []error { return m }

// ReferenceByPartialKeyRequestValidationError is the validation error returned
// by ReferenceByPartialKeyRequest.Validate if the designated constraints
// aren't met.
type ReferenceByPartialKeyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceByPartialKeyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceByPartialKeyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceByPartialKeyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceByPartialKeyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceByPartialKeyRequestValidationError) ErrorName() string {
	return "ReferenceByPartialKeyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReferenceByPartialKeyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceByPartialKeyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceByPartialKeyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceByPartialKeyRequestValidationError{}

// Validate checks the field values on ReferenceByPartialKeyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReferenceByPartialKeyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceByPartialKeyResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ReferenceByPartialKeyResponseMultiError, or nil if none found.
func (m *ReferenceByPartialKeyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceByPartialKeyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	for idx, item := range m.GetReferences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReferenceByPartialKeyResponseValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReferenceByPartialKeyResponseValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReferenceByPartialKeyResponseValidationError{
					field:  fmt.Sprintf("References[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReferenceByPartialKeyResponseMultiError(errors)
	}

	return nil
}

// ReferenceByPartialKeyResponseMultiError is an error wrapping multiple
// validation errors returned by ReferenceByPartialKeyResponse.ValidateAll()
// if the designated constraints aren't met.
type ReferenceByPartialKeyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceByPartialKeyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceByPartialKeyResponseMultiError) AllErrors() []error { return m }

// ReferenceByPartialKeyResponseValidationError is the validation error
// returned by ReferenceByPartialKeyResponse.Validate if the designated
// constraints aren't met.
type ReferenceByPartialKeyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceByPartialKeyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceByPartialKeyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceByPartialKeyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceByPartialKeyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceByPartialKeyResponseValidationError) ErrorName() string {
	return "ReferenceByPartialKeyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReferenceByPartialKeyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceByPartialKeyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceByPartialKeyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceByPartialKeyResponseValidationError{}

// Validate checks the field values on ReferenceByItemRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReferenceByItemRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceByItemRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceByItemRequestMultiError, or nil if none found.
func (m *ReferenceByItemRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceByItemRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	// no validation rules for Limit

	// no validation rules for CollectionId

	if all {
		switch v := interface{}(m.GetItemKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReferenceByItemRequestValidationError{
					field:  "ItemKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReferenceByItemRequestValidationError{
					field:  "ItemKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItemKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReferenceByItemRequestValidationError{
				field:  "ItemKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReferenceByItemRequestMultiError(errors)
	}

	return nil
}

// ReferenceByItemRequestMultiError is an error wrapping multiple validation
// errors returned by ReferenceByItemRequest.ValidateAll() if the designated
// constraints aren't met.
type ReferenceByItemRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceByItemRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceByItemRequestMultiError) AllErrors() []error { return m }

// ReferenceByItemRequestValidationError is the validation error returned by
// ReferenceByItemRequest.Validate if the designated constraints aren't met.
type ReferenceByItemRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceByItemRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceByItemRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceByItemRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceByItemRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceByItemRequestValidationError) ErrorName() string {
	return "ReferenceByItemRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReferenceByItemRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceByItemRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceByItemRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceByItemRequestValidationError{}

// Validate checks the field values on ReferenceByItemResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReferenceByItemResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceByItemResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceByItemResponseMultiError, or nil if none found.
func (m *ReferenceByItemResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceByItemResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	for idx, item := range m.GetReferences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReferenceByItemResponseValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReferenceByItemResponseValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReferenceByItemResponseValidationError{
					field:  fmt.Sprintf("References[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReferenceByItemResponseMultiError(errors)
	}

	return nil
}

// ReferenceByItemResponseMultiError is an error wrapping multiple validation
// errors returned by ReferenceByItemResponse.ValidateAll() if the designated
// constraints aren't met.
type ReferenceByItemResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceByItemResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceByItemResponseMultiError) AllErrors() []error { return m }

// ReferenceByItemResponseValidationError is the validation error returned by
// ReferenceByItemResponse.Validate if the designated constraints aren't met.
type ReferenceByItemResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceByItemResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceByItemResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceByItemResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceByItemResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceByItemResponseValidationError) ErrorName() string {
	return "ReferenceByItemResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReferenceByItemResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceByItemResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceByItemResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceByItemResponseValidationError{}

// Validate checks the field values on ReferenceCreateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReferenceCreateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceCreateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceCreateRequestMultiError, or nil if none found.
func (m *ReferenceCreateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceCreateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRefKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReferenceCreateRequestValidationError{
					field:  "RefKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReferenceCreateRequestValidationError{
					field:  "RefKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReferenceCreateRequestValidationError{
				field:  "RefKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReferenceCreateRequestMultiError(errors)
	}

	return nil
}

// ReferenceCreateRequestMultiError is an error wrapping multiple validation
// errors returned by ReferenceCreateRequest.ValidateAll() if the designated
// constraints aren't met.
type ReferenceCreateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceCreateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceCreateRequestMultiError) AllErrors() []error { return m }

// ReferenceCreateRequestValidationError is the validation error returned by
// ReferenceCreateRequest.Validate if the designated constraints aren't met.
type ReferenceCreateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceCreateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceCreateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceCreateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceCreateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceCreateRequestValidationError) ErrorName() string {
	return "ReferenceCreateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReferenceCreateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceCreateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceCreateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceCreateRequestValidationError{}

// Validate checks the field values on ReferenceCreateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReferenceCreateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceCreateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceCreateResponseMultiError, or nil if none found.
func (m *ReferenceCreateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceCreateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRefKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReferenceCreateResponseValidationError{
					field:  "RefKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReferenceCreateResponseValidationError{
					field:  "RefKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReferenceCreateResponseValidationError{
				field:  "RefKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReferenceCreateResponseMultiError(errors)
	}

	return nil
}

// ReferenceCreateResponseMultiError is an error wrapping multiple validation
// errors returned by ReferenceCreateResponse.ValidateAll() if the designated
// constraints aren't met.
type ReferenceCreateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceCreateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceCreateResponseMultiError) AllErrors() []error { return m }

// ReferenceCreateResponseValidationError is the validation error returned by
// ReferenceCreateResponse.Validate if the designated constraints aren't met.
type ReferenceCreateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceCreateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceCreateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceCreateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceCreateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceCreateResponseValidationError) ErrorName() string {
	return "ReferenceCreateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReferenceCreateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceCreateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceCreateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceCreateResponseValidationError{}

// Validate checks the field values on ReferenceDeleteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReferenceDeleteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceDeleteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceDeleteRequestMultiError, or nil if none found.
func (m *ReferenceDeleteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceDeleteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRefKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReferenceDeleteRequestValidationError{
					field:  "RefKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReferenceDeleteRequestValidationError{
					field:  "RefKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReferenceDeleteRequestValidationError{
				field:  "RefKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReferenceDeleteRequestMultiError(errors)
	}

	return nil
}

// ReferenceDeleteRequestMultiError is an error wrapping multiple validation
// errors returned by ReferenceDeleteRequest.ValidateAll() if the designated
// constraints aren't met.
type ReferenceDeleteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceDeleteRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceDeleteRequestMultiError) AllErrors() []error { return m }

// ReferenceDeleteRequestValidationError is the validation error returned by
// ReferenceDeleteRequest.Validate if the designated constraints aren't met.
type ReferenceDeleteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceDeleteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceDeleteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceDeleteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceDeleteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceDeleteRequestValidationError) ErrorName() string {
	return "ReferenceDeleteRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReferenceDeleteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceDeleteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceDeleteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceDeleteRequestValidationError{}

// Validate checks the field values on ReferenceDeleteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReferenceDeleteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceDeleteResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceDeleteResponseMultiError, or nil if none found.
func (m *ReferenceDeleteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceDeleteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRefKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReferenceDeleteResponseValidationError{
					field:  "RefKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReferenceDeleteResponseValidationError{
					field:  "RefKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReferenceDeleteResponseValidationError{
				field:  "RefKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReferenceDeleteResponseMultiError(errors)
	}

	return nil
}

// ReferenceDeleteResponseMultiError is an error wrapping multiple validation
// errors returned by ReferenceDeleteResponse.ValidateAll() if the designated
// constraints aren't met.
type ReferenceDeleteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceDeleteResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceDeleteResponseMultiError) AllErrors() []error { return m }

// ReferenceDeleteResponseValidationError is the validation error returned by
// ReferenceDeleteResponse.Validate if the designated constraints aren't met.
type ReferenceDeleteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceDeleteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceDeleteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceDeleteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceDeleteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceDeleteResponseValidationError) ErrorName() string {
	return "ReferenceDeleteResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReferenceDeleteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceDeleteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceDeleteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceDeleteResponseValidationError{}
