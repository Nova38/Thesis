// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: chaincode/auth/common/generic.proto

package common

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GetCurrentUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCurrentUserResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCurrentUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCurrentUserResponseMultiError, or nil if none found.
func (m *GetCurrentUserResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCurrentUserResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetCurrentUserResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetCurrentUserResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetCurrentUserResponseValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Registered

	if len(errors) > 0 {
		return GetCurrentUserResponseMultiError(errors)
	}

	return nil
}

// GetCurrentUserResponseMultiError is an error wrapping multiple validation
// errors returned by GetCurrentUserResponse.ValidateAll() if the designated
// constraints aren't met.
type GetCurrentUserResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCurrentUserResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCurrentUserResponseMultiError) AllErrors() []error { return m }

// GetCurrentUserResponseValidationError is the validation error returned by
// GetCurrentUserResponse.Validate if the designated constraints aren't met.
type GetCurrentUserResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCurrentUserResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCurrentUserResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCurrentUserResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCurrentUserResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCurrentUserResponseValidationError) ErrorName() string {
	return "GetCurrentUserResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetCurrentUserResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCurrentUserResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCurrentUserResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCurrentUserResponseValidationError{}

// Validate checks the field values on GetCurrentFullUserResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCurrentFullUserResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCurrentFullUserResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCurrentFullUserResponseMultiError, or nil if none found.
func (m *GetCurrentFullUserResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCurrentFullUserResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetCurrentFullUserResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetCurrentFullUserResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetCurrentFullUserResponseValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Registered

	for idx, item := range m.GetUserCollectionRoles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetCurrentFullUserResponseValidationError{
						field:  fmt.Sprintf("UserCollectionRoles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetCurrentFullUserResponseValidationError{
						field:  fmt.Sprintf("UserCollectionRoles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetCurrentFullUserResponseValidationError{
					field:  fmt.Sprintf("UserCollectionRoles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetUserMemberships() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetCurrentFullUserResponseValidationError{
						field:  fmt.Sprintf("UserMemberships[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetCurrentFullUserResponseValidationError{
						field:  fmt.Sprintf("UserMemberships[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetCurrentFullUserResponseValidationError{
					field:  fmt.Sprintf("UserMemberships[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetCurrentFullUserResponseMultiError(errors)
	}

	return nil
}

// GetCurrentFullUserResponseMultiError is an error wrapping multiple
// validation errors returned by GetCurrentFullUserResponse.ValidateAll() if
// the designated constraints aren't met.
type GetCurrentFullUserResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCurrentFullUserResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCurrentFullUserResponseMultiError) AllErrors() []error { return m }

// GetCurrentFullUserResponseValidationError is the validation error returned
// by GetCurrentFullUserResponse.Validate if the designated constraints aren't met.
type GetCurrentFullUserResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCurrentFullUserResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCurrentFullUserResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCurrentFullUserResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCurrentFullUserResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCurrentFullUserResponseValidationError) ErrorName() string {
	return "GetCurrentFullUserResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetCurrentFullUserResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCurrentFullUserResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCurrentFullUserResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCurrentFullUserResponseValidationError{}

// Validate checks the field values on AuthorizeOperationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthorizeOperationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthorizeOperationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthorizeOperationRequestMultiError, or nil if none found.
func (m *AuthorizeOperationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthorizeOperationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AuthorizeOperationRequestValidationError{
					field:  "Operation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AuthorizeOperationRequestValidationError{
					field:  "Operation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AuthorizeOperationRequestValidationError{
				field:  "Operation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AuthorizeOperationRequestMultiError(errors)
	}

	return nil
}

// AuthorizeOperationRequestMultiError is an error wrapping multiple validation
// errors returned by AuthorizeOperationRequest.ValidateAll() if the
// designated constraints aren't met.
type AuthorizeOperationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthorizeOperationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthorizeOperationRequestMultiError) AllErrors() []error { return m }

// AuthorizeOperationRequestValidationError is the validation error returned by
// AuthorizeOperationRequest.Validate if the designated constraints aren't met.
type AuthorizeOperationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthorizeOperationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthorizeOperationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthorizeOperationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthorizeOperationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthorizeOperationRequestValidationError) ErrorName() string {
	return "AuthorizeOperationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AuthorizeOperationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthorizeOperationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthorizeOperationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthorizeOperationRequestValidationError{}

// Validate checks the field values on AuthorizeOperationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthorizeOperationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthorizeOperationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthorizeOperationResponseMultiError, or nil if none found.
func (m *AuthorizeOperationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthorizeOperationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Authorized

	if len(errors) > 0 {
		return AuthorizeOperationResponseMultiError(errors)
	}

	return nil
}

// AuthorizeOperationResponseMultiError is an error wrapping multiple
// validation errors returned by AuthorizeOperationResponse.ValidateAll() if
// the designated constraints aren't met.
type AuthorizeOperationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthorizeOperationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthorizeOperationResponseMultiError) AllErrors() []error { return m }

// AuthorizeOperationResponseValidationError is the validation error returned
// by AuthorizeOperationResponse.Validate if the designated constraints aren't met.
type AuthorizeOperationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthorizeOperationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthorizeOperationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthorizeOperationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthorizeOperationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthorizeOperationResponseValidationError) ErrorName() string {
	return "AuthorizeOperationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AuthorizeOperationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthorizeOperationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthorizeOperationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthorizeOperationResponseValidationError{}

// Validate checks the field values on BootstrapRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BootstrapRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BootstrapRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BootstrapRequestMultiError, or nil if none found.
func (m *BootstrapRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BootstrapRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AddDefaultSetup

	if len(errors) > 0 {
		return BootstrapRequestMultiError(errors)
	}

	return nil
}

// BootstrapRequestMultiError is an error wrapping multiple validation errors
// returned by BootstrapRequest.ValidateAll() if the designated constraints
// aren't met.
type BootstrapRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BootstrapRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BootstrapRequestMultiError) AllErrors() []error { return m }

// BootstrapRequestValidationError is the validation error returned by
// BootstrapRequest.Validate if the designated constraints aren't met.
type BootstrapRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BootstrapRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BootstrapRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BootstrapRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BootstrapRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BootstrapRequestValidationError) ErrorName() string { return "BootstrapRequestValidationError" }

// Error satisfies the builtin error interface
func (e BootstrapRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBootstrapRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BootstrapRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BootstrapRequestValidationError{}

// Validate checks the field values on BootstrapResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BootstrapResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BootstrapResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BootstrapResponseMultiError, or nil if none found.
func (m *BootstrapResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BootstrapResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	if len(errors) > 0 {
		return BootstrapResponseMultiError(errors)
	}

	return nil
}

// BootstrapResponseMultiError is an error wrapping multiple validation errors
// returned by BootstrapResponse.ValidateAll() if the designated constraints
// aren't met.
type BootstrapResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BootstrapResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BootstrapResponseMultiError) AllErrors() []error { return m }

// BootstrapResponseValidationError is the validation error returned by
// BootstrapResponse.Validate if the designated constraints aren't met.
type BootstrapResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BootstrapResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BootstrapResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BootstrapResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BootstrapResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BootstrapResponseValidationError) ErrorName() string {
	return "BootstrapResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BootstrapResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBootstrapResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BootstrapResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BootstrapResponseValidationError{}

// Validate checks the field values on CreateCollectionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCollectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCollectionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCollectionRequestMultiError, or nil if none found.
func (m *CreateCollectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCollectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCollection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCollectionRequestValidationError{
					field:  "Collection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCollectionRequestValidationError{
					field:  "Collection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCollection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCollectionRequestValidationError{
				field:  "Collection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateCollectionRequestMultiError(errors)
	}

	return nil
}

// CreateCollectionRequestMultiError is an error wrapping multiple validation
// errors returned by CreateCollectionRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateCollectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCollectionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCollectionRequestMultiError) AllErrors() []error { return m }

// CreateCollectionRequestValidationError is the validation error returned by
// CreateCollectionRequest.Validate if the designated constraints aren't met.
type CreateCollectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCollectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCollectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCollectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCollectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCollectionRequestValidationError) ErrorName() string {
	return "CreateCollectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCollectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCollectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCollectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCollectionRequestValidationError{}

// Validate checks the field values on CreateCollectionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCollectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCollectionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCollectionResponseMultiError, or nil if none found.
func (m *CreateCollectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCollectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCollection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCollectionResponseValidationError{
					field:  "Collection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCollectionResponseValidationError{
					field:  "Collection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCollection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCollectionResponseValidationError{
				field:  "Collection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateCollectionResponseMultiError(errors)
	}

	return nil
}

// CreateCollectionResponseMultiError is an error wrapping multiple validation
// errors returned by CreateCollectionResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateCollectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCollectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCollectionResponseMultiError) AllErrors() []error { return m }

// CreateCollectionResponseValidationError is the validation error returned by
// CreateCollectionResponse.Validate if the designated constraints aren't met.
type CreateCollectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCollectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCollectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCollectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCollectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCollectionResponseValidationError) ErrorName() string {
	return "CreateCollectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCollectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCollectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCollectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCollectionResponseValidationError{}

// Validate checks the field values on CreateUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateUserResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateUserResponseMultiError, or nil if none found.
func (m *CreateUserResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateUserResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateUserResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateUserResponseValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateUserResponseMultiError(errors)
	}

	return nil
}

// CreateUserResponseMultiError is an error wrapping multiple validation errors
// returned by CreateUserResponse.ValidateAll() if the designated constraints
// aren't met.
type CreateUserResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserResponseMultiError) AllErrors() []error { return m }

// CreateUserResponseValidationError is the validation error returned by
// CreateUserResponse.Validate if the designated constraints aren't met.
type CreateUserResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserResponseValidationError) ErrorName() string {
	return "CreateUserResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateUserResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserResponseValidationError{}

// Validate checks the field values on GetRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetRequestMultiError, or
// nil if none found.
func (m *GetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetRequestValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetRequestMultiError(errors)
	}

	return nil
}

// GetRequestMultiError is an error wrapping multiple validation errors
// returned by GetRequest.ValidateAll() if the designated constraints aren't met.
type GetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRequestMultiError) AllErrors() []error { return m }

// GetRequestValidationError is the validation error returned by
// GetRequest.Validate if the designated constraints aren't met.
type GetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRequestValidationError) ErrorName() string { return "GetRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRequestValidationError{}

// Validate checks the field values on GetResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetResponseMultiError, or
// nil if none found.
func (m *GetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetResponseValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetResponseMultiError(errors)
	}

	return nil
}

// GetResponseMultiError is an error wrapping multiple validation errors
// returned by GetResponse.ValidateAll() if the designated constraints aren't met.
type GetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetResponseMultiError) AllErrors() []error { return m }

// GetResponseValidationError is the validation error returned by
// GetResponse.Validate if the designated constraints aren't met.
type GetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetResponseValidationError) ErrorName() string { return "GetResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetResponseValidationError{}

// Validate checks the field values on ListRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListRequestMultiError, or
// nil if none found.
func (m *ListRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	// no validation rules for Limit

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListRequestValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListRequestMultiError(errors)
	}

	return nil
}

// ListRequestMultiError is an error wrapping multiple validation errors
// returned by ListRequest.ValidateAll() if the designated constraints aren't met.
type ListRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRequestMultiError) AllErrors() []error { return m }

// ListRequestValidationError is the validation error returned by
// ListRequest.Validate if the designated constraints aren't met.
type ListRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRequestValidationError) ErrorName() string { return "ListRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRequestValidationError{}

// Validate checks the field values on ListResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListResponseMultiError, or
// nil if none found.
func (m *ListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListResponseMultiError(errors)
	}

	return nil
}

// ListResponseMultiError is an error wrapping multiple validation errors
// returned by ListResponse.ValidateAll() if the designated constraints aren't met.
type ListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListResponseMultiError) AllErrors() []error { return m }

// ListResponseValidationError is the validation error returned by
// ListResponse.Validate if the designated constraints aren't met.
type ListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListResponseValidationError) ErrorName() string { return "ListResponseValidationError" }

// Error satisfies the builtin error interface
func (e ListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListResponseValidationError{}

// Validate checks the field values on ListByCollectionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListByCollectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListByCollectionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListByCollectionRequestMultiError, or nil if none found.
func (m *ListByCollectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListByCollectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	// no validation rules for Limit

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListByCollectionRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListByCollectionRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListByCollectionRequestValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListByCollectionRequestMultiError(errors)
	}

	return nil
}

// ListByCollectionRequestMultiError is an error wrapping multiple validation
// errors returned by ListByCollectionRequest.ValidateAll() if the designated
// constraints aren't met.
type ListByCollectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListByCollectionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListByCollectionRequestMultiError) AllErrors() []error { return m }

// ListByCollectionRequestValidationError is the validation error returned by
// ListByCollectionRequest.Validate if the designated constraints aren't met.
type ListByCollectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListByCollectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListByCollectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListByCollectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListByCollectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListByCollectionRequestValidationError) ErrorName() string {
	return "ListByCollectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListByCollectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListByCollectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListByCollectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListByCollectionRequestValidationError{}

// Validate checks the field values on ListByCollectionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListByCollectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListByCollectionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListByCollectionResponseMultiError, or nil if none found.
func (m *ListByCollectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListByCollectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListByCollectionResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListByCollectionResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListByCollectionResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListByCollectionResponseMultiError(errors)
	}

	return nil
}

// ListByCollectionResponseMultiError is an error wrapping multiple validation
// errors returned by ListByCollectionResponse.ValidateAll() if the designated
// constraints aren't met.
type ListByCollectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListByCollectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListByCollectionResponseMultiError) AllErrors() []error { return m }

// ListByCollectionResponseValidationError is the validation error returned by
// ListByCollectionResponse.Validate if the designated constraints aren't met.
type ListByCollectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListByCollectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListByCollectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListByCollectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListByCollectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListByCollectionResponseValidationError) ErrorName() string {
	return "ListByCollectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListByCollectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListByCollectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListByCollectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListByCollectionResponseValidationError{}

// Validate checks the field values on ListByAttrsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListByAttrsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListByAttrsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListByAttrsRequestMultiError, or nil if none found.
func (m *ListByAttrsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListByAttrsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	// no validation rules for Limit

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListByAttrsRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListByAttrsRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListByAttrsRequestValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NumAttrs

	if len(errors) > 0 {
		return ListByAttrsRequestMultiError(errors)
	}

	return nil
}

// ListByAttrsRequestMultiError is an error wrapping multiple validation errors
// returned by ListByAttrsRequest.ValidateAll() if the designated constraints
// aren't met.
type ListByAttrsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListByAttrsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListByAttrsRequestMultiError) AllErrors() []error { return m }

// ListByAttrsRequestValidationError is the validation error returned by
// ListByAttrsRequest.Validate if the designated constraints aren't met.
type ListByAttrsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListByAttrsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListByAttrsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListByAttrsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListByAttrsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListByAttrsRequestValidationError) ErrorName() string {
	return "ListByAttrsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListByAttrsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListByAttrsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListByAttrsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListByAttrsRequestValidationError{}

// Validate checks the field values on ListByAttrsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListByAttrsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListByAttrsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListByAttrsResponseMultiError, or nil if none found.
func (m *ListByAttrsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListByAttrsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListByAttrsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListByAttrsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListByAttrsResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListByAttrsResponseMultiError(errors)
	}

	return nil
}

// ListByAttrsResponseMultiError is an error wrapping multiple validation
// errors returned by ListByAttrsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListByAttrsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListByAttrsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListByAttrsResponseMultiError) AllErrors() []error { return m }

// ListByAttrsResponseValidationError is the validation error returned by
// ListByAttrsResponse.Validate if the designated constraints aren't met.
type ListByAttrsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListByAttrsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListByAttrsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListByAttrsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListByAttrsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListByAttrsResponseValidationError) ErrorName() string {
	return "ListByAttrsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListByAttrsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListByAttrsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListByAttrsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListByAttrsResponseValidationError{}

// Validate checks the field values on CreateRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateRequestMultiError, or
// nil if none found.
func (m *CreateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateRequestValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateRequestMultiError(errors)
	}

	return nil
}

// CreateRequestMultiError is an error wrapping multiple validation errors
// returned by CreateRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRequestMultiError) AllErrors() []error { return m }

// CreateRequestValidationError is the validation error returned by
// CreateRequest.Validate if the designated constraints aren't met.
type CreateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRequestValidationError) ErrorName() string { return "CreateRequestValidationError" }

// Error satisfies the builtin error interface
func (e CreateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRequestValidationError{}

// Validate checks the field values on CreateResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateResponseMultiError,
// or nil if none found.
func (m *CreateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateResponseValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateResponseMultiError(errors)
	}

	return nil
}

// CreateResponseMultiError is an error wrapping multiple validation errors
// returned by CreateResponse.ValidateAll() if the designated constraints
// aren't met.
type CreateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateResponseMultiError) AllErrors() []error { return m }

// CreateResponseValidationError is the validation error returned by
// CreateResponse.Validate if the designated constraints aren't met.
type CreateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateResponseValidationError) ErrorName() string { return "CreateResponseValidationError" }

// Error satisfies the builtin error interface
func (e CreateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateResponseValidationError{}

// Validate checks the field values on UpdateRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateRequestMultiError, or
// nil if none found.
func (m *UpdateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRequestValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateMask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRequestValidationError{
					field:  "UpdateMask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRequestValidationError{
					field:  "UpdateMask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateMask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRequestValidationError{
				field:  "UpdateMask",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateRequestMultiError(errors)
	}

	return nil
}

// UpdateRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRequestMultiError) AllErrors() []error { return m }

// UpdateRequestValidationError is the validation error returned by
// UpdateRequest.Validate if the designated constraints aren't met.
type UpdateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRequestValidationError) ErrorName() string { return "UpdateRequestValidationError" }

// Error satisfies the builtin error interface
func (e UpdateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRequestValidationError{}

// Validate checks the field values on UpdateResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateResponseMultiError,
// or nil if none found.
func (m *UpdateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateResponseValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateResponseMultiError(errors)
	}

	return nil
}

// UpdateResponseMultiError is an error wrapping multiple validation errors
// returned by UpdateResponse.ValidateAll() if the designated constraints
// aren't met.
type UpdateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateResponseMultiError) AllErrors() []error { return m }

// UpdateResponseValidationError is the validation error returned by
// UpdateResponse.Validate if the designated constraints aren't met.
type UpdateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateResponseValidationError) ErrorName() string { return "UpdateResponseValidationError" }

// Error satisfies the builtin error interface
func (e UpdateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateResponseValidationError{}

// Validate checks the field values on DeleteRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteRequestMultiError, or
// nil if none found.
func (m *DeleteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteRequestValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Reason

	if len(errors) > 0 {
		return DeleteRequestMultiError(errors)
	}

	return nil
}

// DeleteRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRequestMultiError) AllErrors() []error { return m }

// DeleteRequestValidationError is the validation error returned by
// DeleteRequest.Validate if the designated constraints aren't met.
type DeleteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRequestValidationError) ErrorName() string { return "DeleteRequestValidationError" }

// Error satisfies the builtin error interface
func (e DeleteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRequestValidationError{}

// Validate checks the field values on DeleteResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteResponseMultiError,
// or nil if none found.
func (m *DeleteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteResponseValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteResponseMultiError(errors)
	}

	return nil
}

// DeleteResponseMultiError is an error wrapping multiple validation errors
// returned by DeleteResponse.ValidateAll() if the designated constraints
// aren't met.
type DeleteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteResponseMultiError) AllErrors() []error { return m }

// DeleteResponseValidationError is the validation error returned by
// DeleteResponse.Validate if the designated constraints aren't met.
type DeleteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteResponseValidationError) ErrorName() string { return "DeleteResponseValidationError" }

// Error satisfies the builtin error interface
func (e DeleteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteResponseValidationError{}

// Validate checks the field values on HistoryRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HistoryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HistoryRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HistoryRequestMultiError,
// or nil if none found.
func (m *HistoryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HistoryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HistoryRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HistoryRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HistoryRequestValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HistoryRequestMultiError(errors)
	}

	return nil
}

// HistoryRequestMultiError is an error wrapping multiple validation errors
// returned by HistoryRequest.ValidateAll() if the designated constraints
// aren't met.
type HistoryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HistoryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HistoryRequestMultiError) AllErrors() []error { return m }

// HistoryRequestValidationError is the validation error returned by
// HistoryRequest.Validate if the designated constraints aren't met.
type HistoryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HistoryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HistoryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HistoryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HistoryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HistoryRequestValidationError) ErrorName() string { return "HistoryRequestValidationError" }

// Error satisfies the builtin error interface
func (e HistoryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHistoryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HistoryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HistoryRequestValidationError{}

// Validate checks the field values on HistoryResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HistoryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HistoryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HistoryResponseMultiError, or nil if none found.
func (m *HistoryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *HistoryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetHistory()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HistoryResponseValidationError{
					field:  "History",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HistoryResponseValidationError{
					field:  "History",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHistory()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HistoryResponseValidationError{
				field:  "History",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HistoryResponseMultiError(errors)
	}

	return nil
}

// HistoryResponseMultiError is an error wrapping multiple validation errors
// returned by HistoryResponse.ValidateAll() if the designated constraints
// aren't met.
type HistoryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HistoryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HistoryResponseMultiError) AllErrors() []error { return m }

// HistoryResponseValidationError is the validation error returned by
// HistoryResponse.Validate if the designated constraints aren't met.
type HistoryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HistoryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HistoryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HistoryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HistoryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HistoryResponseValidationError) ErrorName() string { return "HistoryResponseValidationError" }

// Error satisfies the builtin error interface
func (e HistoryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHistoryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HistoryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HistoryResponseValidationError{}

// Validate checks the field values on HiddenTxRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HiddenTxRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HiddenTxRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HiddenTxRequestMultiError, or nil if none found.
func (m *HiddenTxRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HiddenTxRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HiddenTxRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HiddenTxRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HiddenTxRequestValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HiddenTxRequestMultiError(errors)
	}

	return nil
}

// HiddenTxRequestMultiError is an error wrapping multiple validation errors
// returned by HiddenTxRequest.ValidateAll() if the designated constraints
// aren't met.
type HiddenTxRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HiddenTxRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HiddenTxRequestMultiError) AllErrors() []error { return m }

// HiddenTxRequestValidationError is the validation error returned by
// HiddenTxRequest.Validate if the designated constraints aren't met.
type HiddenTxRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HiddenTxRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HiddenTxRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HiddenTxRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HiddenTxRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HiddenTxRequestValidationError) ErrorName() string { return "HiddenTxRequestValidationError" }

// Error satisfies the builtin error interface
func (e HiddenTxRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHiddenTxRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HiddenTxRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HiddenTxRequestValidationError{}

// Validate checks the field values on HiddenTxResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HiddenTxResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HiddenTxResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HiddenTxResponseMultiError, or nil if none found.
func (m *HiddenTxResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *HiddenTxResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CollectionId

	for idx, item := range m.GetHiddenTxs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HiddenTxResponseValidationError{
						field:  fmt.Sprintf("HiddenTxs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HiddenTxResponseValidationError{
						field:  fmt.Sprintf("HiddenTxs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HiddenTxResponseValidationError{
					field:  fmt.Sprintf("HiddenTxs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HiddenTxResponseMultiError(errors)
	}

	return nil
}

// HiddenTxResponseMultiError is an error wrapping multiple validation errors
// returned by HiddenTxResponse.ValidateAll() if the designated constraints
// aren't met.
type HiddenTxResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HiddenTxResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HiddenTxResponseMultiError) AllErrors() []error { return m }

// HiddenTxResponseValidationError is the validation error returned by
// HiddenTxResponse.Validate if the designated constraints aren't met.
type HiddenTxResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HiddenTxResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HiddenTxResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HiddenTxResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HiddenTxResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HiddenTxResponseValidationError) ErrorName() string { return "HiddenTxResponseValidationError" }

// Error satisfies the builtin error interface
func (e HiddenTxResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHiddenTxResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HiddenTxResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HiddenTxResponseValidationError{}

// Validate checks the field values on HideTxRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HideTxRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HideTxRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HideTxRequestMultiError, or
// nil if none found.
func (m *HideTxRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HideTxRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HideTxRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HideTxRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HideTxRequestValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetHiddenTx()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HideTxRequestValidationError{
					field:  "HiddenTx",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HideTxRequestValidationError{
					field:  "HiddenTx",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHiddenTx()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HideTxRequestValidationError{
				field:  "HiddenTx",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HideTxRequestMultiError(errors)
	}

	return nil
}

// HideTxRequestMultiError is an error wrapping multiple validation errors
// returned by HideTxRequest.ValidateAll() if the designated constraints
// aren't met.
type HideTxRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HideTxRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HideTxRequestMultiError) AllErrors() []error { return m }

// HideTxRequestValidationError is the validation error returned by
// HideTxRequest.Validate if the designated constraints aren't met.
type HideTxRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HideTxRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HideTxRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HideTxRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HideTxRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HideTxRequestValidationError) ErrorName() string { return "HideTxRequestValidationError" }

// Error satisfies the builtin error interface
func (e HideTxRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHideTxRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HideTxRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HideTxRequestValidationError{}

// Validate checks the field values on HideTxResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HideTxResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HideTxResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HideTxResponseMultiError,
// or nil if none found.
func (m *HideTxResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *HideTxResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HideTxResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HideTxResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HideTxResponseValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetHiddenTxs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HideTxResponseValidationError{
					field:  "HiddenTxs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HideTxResponseValidationError{
					field:  "HiddenTxs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHiddenTxs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HideTxResponseValidationError{
				field:  "HiddenTxs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HideTxResponseMultiError(errors)
	}

	return nil
}

// HideTxResponseMultiError is an error wrapping multiple validation errors
// returned by HideTxResponse.ValidateAll() if the designated constraints
// aren't met.
type HideTxResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HideTxResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HideTxResponseMultiError) AllErrors() []error { return m }

// HideTxResponseValidationError is the validation error returned by
// HideTxResponse.Validate if the designated constraints aren't met.
type HideTxResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HideTxResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HideTxResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HideTxResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HideTxResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HideTxResponseValidationError) ErrorName() string { return "HideTxResponseValidationError" }

// Error satisfies the builtin error interface
func (e HideTxResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHideTxResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HideTxResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HideTxResponseValidationError{}

// Validate checks the field values on UnHideTxRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UnHideTxRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnHideTxRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnHideTxRequestMultiError, or nil if none found.
func (m *UnHideTxRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UnHideTxRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UnHideTxRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UnHideTxRequestValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UnHideTxRequestValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TxId

	if len(errors) > 0 {
		return UnHideTxRequestMultiError(errors)
	}

	return nil
}

// UnHideTxRequestMultiError is an error wrapping multiple validation errors
// returned by UnHideTxRequest.ValidateAll() if the designated constraints
// aren't met.
type UnHideTxRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnHideTxRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnHideTxRequestMultiError) AllErrors() []error { return m }

// UnHideTxRequestValidationError is the validation error returned by
// UnHideTxRequest.Validate if the designated constraints aren't met.
type UnHideTxRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnHideTxRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnHideTxRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnHideTxRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnHideTxRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnHideTxRequestValidationError) ErrorName() string { return "UnHideTxRequestValidationError" }

// Error satisfies the builtin error interface
func (e UnHideTxRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnHideTxRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnHideTxRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnHideTxRequestValidationError{}

// Validate checks the field values on UnHideTxResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UnHideTxResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnHideTxResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnHideTxResponseMultiError, or nil if none found.
func (m *UnHideTxResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UnHideTxResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UnHideTxResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UnHideTxResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UnHideTxResponseValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetHiddenTxs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UnHideTxResponseValidationError{
					field:  "HiddenTxs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UnHideTxResponseValidationError{
					field:  "HiddenTxs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHiddenTxs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UnHideTxResponseValidationError{
				field:  "HiddenTxs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UnHideTxResponseMultiError(errors)
	}

	return nil
}

// UnHideTxResponseMultiError is an error wrapping multiple validation errors
// returned by UnHideTxResponse.ValidateAll() if the designated constraints
// aren't met.
type UnHideTxResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnHideTxResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnHideTxResponseMultiError) AllErrors() []error { return m }

// UnHideTxResponseValidationError is the validation error returned by
// UnHideTxResponse.Validate if the designated constraints aren't met.
type UnHideTxResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnHideTxResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnHideTxResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnHideTxResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnHideTxResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnHideTxResponseValidationError) ErrorName() string { return "UnHideTxResponseValidationError" }

// Error satisfies the builtin error interface
func (e UnHideTxResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnHideTxResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnHideTxResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnHideTxResponseValidationError{}

// Validate checks the field values on ReferenceRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReferenceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceRequestMultiError, or nil if none found.
func (m *ReferenceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetReference()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReferenceRequestValidationError{
					field:  "Reference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReferenceRequestValidationError{
					field:  "Reference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReference()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReferenceRequestValidationError{
				field:  "Reference",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReferenceRequestMultiError(errors)
	}

	return nil
}

// ReferenceRequestMultiError is an error wrapping multiple validation errors
// returned by ReferenceRequest.ValidateAll() if the designated constraints
// aren't met.
type ReferenceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceRequestMultiError) AllErrors() []error { return m }

// ReferenceRequestValidationError is the validation error returned by
// ReferenceRequest.Validate if the designated constraints aren't met.
type ReferenceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceRequestValidationError) ErrorName() string { return "ReferenceRequestValidationError" }

// Error satisfies the builtin error interface
func (e ReferenceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceRequestValidationError{}

// Validate checks the field values on ReferenceResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReferenceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceResponseMultiError, or nil if none found.
func (m *ReferenceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Exists

	if all {
		switch v := interface{}(m.GetReference()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReferenceResponseValidationError{
					field:  "Reference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReferenceResponseValidationError{
					field:  "Reference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReference()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReferenceResponseValidationError{
				field:  "Reference",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReferenceResponseMultiError(errors)
	}

	return nil
}

// ReferenceResponseMultiError is an error wrapping multiple validation errors
// returned by ReferenceResponse.ValidateAll() if the designated constraints
// aren't met.
type ReferenceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceResponseMultiError) AllErrors() []error { return m }

// ReferenceResponseValidationError is the validation error returned by
// ReferenceResponse.Validate if the designated constraints aren't met.
type ReferenceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceResponseValidationError) ErrorName() string {
	return "ReferenceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReferenceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceResponseValidationError{}

// Validate checks the field values on ReferenceByCollectionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReferenceByCollectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceByCollectionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceByCollectionRequestMultiError, or nil if none found.
func (m *ReferenceByCollectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceByCollectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	// no validation rules for Limit

	// no validation rules for CollectionId

	if len(errors) > 0 {
		return ReferenceByCollectionRequestMultiError(errors)
	}

	return nil
}

// ReferenceByCollectionRequestMultiError is an error wrapping multiple
// validation errors returned by ReferenceByCollectionRequest.ValidateAll() if
// the designated constraints aren't met.
type ReferenceByCollectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceByCollectionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceByCollectionRequestMultiError) AllErrors() []error { return m }

// ReferenceByCollectionRequestValidationError is the validation error returned
// by ReferenceByCollectionRequest.Validate if the designated constraints
// aren't met.
type ReferenceByCollectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceByCollectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceByCollectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceByCollectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceByCollectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceByCollectionRequestValidationError) ErrorName() string {
	return "ReferenceByCollectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReferenceByCollectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceByCollectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceByCollectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceByCollectionRequestValidationError{}

// Validate checks the field values on ReferenceByCollectionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReferenceByCollectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceByCollectionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ReferenceByCollectionResponseMultiError, or nil if none found.
func (m *ReferenceByCollectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceByCollectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	for idx, item := range m.GetReferences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReferenceByCollectionResponseValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReferenceByCollectionResponseValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReferenceByCollectionResponseValidationError{
					field:  fmt.Sprintf("References[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReferenceByCollectionResponseMultiError(errors)
	}

	return nil
}

// ReferenceByCollectionResponseMultiError is an error wrapping multiple
// validation errors returned by ReferenceByCollectionResponse.ValidateAll()
// if the designated constraints aren't met.
type ReferenceByCollectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceByCollectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceByCollectionResponseMultiError) AllErrors() []error { return m }

// ReferenceByCollectionResponseValidationError is the validation error
// returned by ReferenceByCollectionResponse.Validate if the designated
// constraints aren't met.
type ReferenceByCollectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceByCollectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceByCollectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceByCollectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceByCollectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceByCollectionResponseValidationError) ErrorName() string {
	return "ReferenceByCollectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReferenceByCollectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceByCollectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceByCollectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceByCollectionResponseValidationError{}

// Validate checks the field values on ReferenceByPartialKeyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReferenceByPartialKeyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceByPartialKeyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceByPartialKeyRequestMultiError, or nil if none found.
func (m *ReferenceByPartialKeyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceByPartialKeyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	// no validation rules for Limit

	if all {
		switch v := interface{}(m.GetReference()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReferenceByPartialKeyRequestValidationError{
					field:  "Reference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReferenceByPartialKeyRequestValidationError{
					field:  "Reference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReference()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReferenceByPartialKeyRequestValidationError{
				field:  "Reference",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReferenceByPartialKeyRequestMultiError(errors)
	}

	return nil
}

// ReferenceByPartialKeyRequestMultiError is an error wrapping multiple
// validation errors returned by ReferenceByPartialKeyRequest.ValidateAll() if
// the designated constraints aren't met.
type ReferenceByPartialKeyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceByPartialKeyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceByPartialKeyRequestMultiError) AllErrors() []error { return m }

// ReferenceByPartialKeyRequestValidationError is the validation error returned
// by ReferenceByPartialKeyRequest.Validate if the designated constraints
// aren't met.
type ReferenceByPartialKeyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceByPartialKeyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceByPartialKeyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceByPartialKeyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceByPartialKeyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceByPartialKeyRequestValidationError) ErrorName() string {
	return "ReferenceByPartialKeyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReferenceByPartialKeyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceByPartialKeyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceByPartialKeyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceByPartialKeyRequestValidationError{}

// Validate checks the field values on ReferenceByPartialKeyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReferenceByPartialKeyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceByPartialKeyResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ReferenceByPartialKeyResponseMultiError, or nil if none found.
func (m *ReferenceByPartialKeyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceByPartialKeyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	for idx, item := range m.GetReferences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReferenceByPartialKeyResponseValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReferenceByPartialKeyResponseValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReferenceByPartialKeyResponseValidationError{
					field:  fmt.Sprintf("References[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReferenceByPartialKeyResponseMultiError(errors)
	}

	return nil
}

// ReferenceByPartialKeyResponseMultiError is an error wrapping multiple
// validation errors returned by ReferenceByPartialKeyResponse.ValidateAll()
// if the designated constraints aren't met.
type ReferenceByPartialKeyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceByPartialKeyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceByPartialKeyResponseMultiError) AllErrors() []error { return m }

// ReferenceByPartialKeyResponseValidationError is the validation error
// returned by ReferenceByPartialKeyResponse.Validate if the designated
// constraints aren't met.
type ReferenceByPartialKeyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceByPartialKeyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceByPartialKeyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceByPartialKeyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceByPartialKeyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceByPartialKeyResponseValidationError) ErrorName() string {
	return "ReferenceByPartialKeyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReferenceByPartialKeyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceByPartialKeyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceByPartialKeyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceByPartialKeyResponseValidationError{}

// Validate checks the field values on ReferenceByItemRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReferenceByItemRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceByItemRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceByItemRequestMultiError, or nil if none found.
func (m *ReferenceByItemRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceByItemRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	// no validation rules for Limit

	// no validation rules for CollectionId

	if all {
		switch v := interface{}(m.GetItemKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReferenceByItemRequestValidationError{
					field:  "ItemKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReferenceByItemRequestValidationError{
					field:  "ItemKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItemKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReferenceByItemRequestValidationError{
				field:  "ItemKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReferenceByItemRequestMultiError(errors)
	}

	return nil
}

// ReferenceByItemRequestMultiError is an error wrapping multiple validation
// errors returned by ReferenceByItemRequest.ValidateAll() if the designated
// constraints aren't met.
type ReferenceByItemRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceByItemRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceByItemRequestMultiError) AllErrors() []error { return m }

// ReferenceByItemRequestValidationError is the validation error returned by
// ReferenceByItemRequest.Validate if the designated constraints aren't met.
type ReferenceByItemRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceByItemRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceByItemRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceByItemRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceByItemRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceByItemRequestValidationError) ErrorName() string {
	return "ReferenceByItemRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReferenceByItemRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceByItemRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceByItemRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceByItemRequestValidationError{}

// Validate checks the field values on ReferenceByItemResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReferenceByItemResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceByItemResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceByItemResponseMultiError, or nil if none found.
func (m *ReferenceByItemResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceByItemResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	for idx, item := range m.GetReferences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReferenceByItemResponseValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReferenceByItemResponseValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReferenceByItemResponseValidationError{
					field:  fmt.Sprintf("References[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReferenceByItemResponseMultiError(errors)
	}

	return nil
}

// ReferenceByItemResponseMultiError is an error wrapping multiple validation
// errors returned by ReferenceByItemResponse.ValidateAll() if the designated
// constraints aren't met.
type ReferenceByItemResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceByItemResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceByItemResponseMultiError) AllErrors() []error { return m }

// ReferenceByItemResponseValidationError is the validation error returned by
// ReferenceByItemResponse.Validate if the designated constraints aren't met.
type ReferenceByItemResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceByItemResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceByItemResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceByItemResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceByItemResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceByItemResponseValidationError) ErrorName() string {
	return "ReferenceByItemResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReferenceByItemResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceByItemResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceByItemResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceByItemResponseValidationError{}

// Validate checks the field values on ReferenceCreateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReferenceCreateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceCreateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceCreateRequestMultiError, or nil if none found.
func (m *ReferenceCreateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceCreateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRefKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReferenceCreateRequestValidationError{
					field:  "RefKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReferenceCreateRequestValidationError{
					field:  "RefKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReferenceCreateRequestValidationError{
				field:  "RefKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReferenceCreateRequestMultiError(errors)
	}

	return nil
}

// ReferenceCreateRequestMultiError is an error wrapping multiple validation
// errors returned by ReferenceCreateRequest.ValidateAll() if the designated
// constraints aren't met.
type ReferenceCreateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceCreateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceCreateRequestMultiError) AllErrors() []error { return m }

// ReferenceCreateRequestValidationError is the validation error returned by
// ReferenceCreateRequest.Validate if the designated constraints aren't met.
type ReferenceCreateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceCreateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceCreateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceCreateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceCreateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceCreateRequestValidationError) ErrorName() string {
	return "ReferenceCreateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReferenceCreateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceCreateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceCreateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceCreateRequestValidationError{}

// Validate checks the field values on ReferenceCreateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReferenceCreateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceCreateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceCreateResponseMultiError, or nil if none found.
func (m *ReferenceCreateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceCreateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRefKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReferenceCreateResponseValidationError{
					field:  "RefKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReferenceCreateResponseValidationError{
					field:  "RefKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReferenceCreateResponseValidationError{
				field:  "RefKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReferenceCreateResponseMultiError(errors)
	}

	return nil
}

// ReferenceCreateResponseMultiError is an error wrapping multiple validation
// errors returned by ReferenceCreateResponse.ValidateAll() if the designated
// constraints aren't met.
type ReferenceCreateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceCreateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceCreateResponseMultiError) AllErrors() []error { return m }

// ReferenceCreateResponseValidationError is the validation error returned by
// ReferenceCreateResponse.Validate if the designated constraints aren't met.
type ReferenceCreateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceCreateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceCreateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceCreateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceCreateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceCreateResponseValidationError) ErrorName() string {
	return "ReferenceCreateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReferenceCreateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceCreateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceCreateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceCreateResponseValidationError{}

// Validate checks the field values on ReferenceDeleteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReferenceDeleteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceDeleteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceDeleteRequestMultiError, or nil if none found.
func (m *ReferenceDeleteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceDeleteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRefKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReferenceDeleteRequestValidationError{
					field:  "RefKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReferenceDeleteRequestValidationError{
					field:  "RefKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReferenceDeleteRequestValidationError{
				field:  "RefKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReferenceDeleteRequestMultiError(errors)
	}

	return nil
}

// ReferenceDeleteRequestMultiError is an error wrapping multiple validation
// errors returned by ReferenceDeleteRequest.ValidateAll() if the designated
// constraints aren't met.
type ReferenceDeleteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceDeleteRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceDeleteRequestMultiError) AllErrors() []error { return m }

// ReferenceDeleteRequestValidationError is the validation error returned by
// ReferenceDeleteRequest.Validate if the designated constraints aren't met.
type ReferenceDeleteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceDeleteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceDeleteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceDeleteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceDeleteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceDeleteRequestValidationError) ErrorName() string {
	return "ReferenceDeleteRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReferenceDeleteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceDeleteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceDeleteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceDeleteRequestValidationError{}

// Validate checks the field values on ReferenceDeleteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReferenceDeleteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceDeleteResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceDeleteResponseMultiError, or nil if none found.
func (m *ReferenceDeleteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceDeleteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRefKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReferenceDeleteResponseValidationError{
					field:  "RefKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReferenceDeleteResponseValidationError{
					field:  "RefKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReferenceDeleteResponseValidationError{
				field:  "RefKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReferenceDeleteResponseMultiError(errors)
	}

	return nil
}

// ReferenceDeleteResponseMultiError is an error wrapping multiple validation
// errors returned by ReferenceDeleteResponse.ValidateAll() if the designated
// constraints aren't met.
type ReferenceDeleteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceDeleteResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceDeleteResponseMultiError) AllErrors() []error { return m }

// ReferenceDeleteResponseValidationError is the validation error returned by
// ReferenceDeleteResponse.Validate if the designated constraints aren't met.
type ReferenceDeleteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceDeleteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceDeleteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceDeleteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceDeleteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceDeleteResponseValidationError) ErrorName() string {
	return "ReferenceDeleteResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReferenceDeleteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceDeleteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceDeleteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceDeleteResponseValidationError{}

// Validate checks the field values on SuggestionRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SuggestionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SuggestionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SuggestionRequestMultiError, or nil if none found.
func (m *SuggestionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SuggestionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItemKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SuggestionRequestValidationError{
					field:  "ItemKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SuggestionRequestValidationError{
					field:  "ItemKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItemKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SuggestionRequestValidationError{
				field:  "ItemKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SuggestionId

	if len(errors) > 0 {
		return SuggestionRequestMultiError(errors)
	}

	return nil
}

// SuggestionRequestMultiError is an error wrapping multiple validation errors
// returned by SuggestionRequest.ValidateAll() if the designated constraints
// aren't met.
type SuggestionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SuggestionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SuggestionRequestMultiError) AllErrors() []error { return m }

// SuggestionRequestValidationError is the validation error returned by
// SuggestionRequest.Validate if the designated constraints aren't met.
type SuggestionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SuggestionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SuggestionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SuggestionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SuggestionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SuggestionRequestValidationError) ErrorName() string {
	return "SuggestionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SuggestionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSuggestionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SuggestionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SuggestionRequestValidationError{}

// Validate checks the field values on SuggestionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SuggestionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SuggestionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SuggestionResponseMultiError, or nil if none found.
func (m *SuggestionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SuggestionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSuggestion()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SuggestionResponseValidationError{
					field:  "Suggestion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SuggestionResponseValidationError{
					field:  "Suggestion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSuggestion()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SuggestionResponseValidationError{
				field:  "Suggestion",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SuggestionResponseMultiError(errors)
	}

	return nil
}

// SuggestionResponseMultiError is an error wrapping multiple validation errors
// returned by SuggestionResponse.ValidateAll() if the designated constraints
// aren't met.
type SuggestionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SuggestionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SuggestionResponseMultiError) AllErrors() []error { return m }

// SuggestionResponseValidationError is the validation error returned by
// SuggestionResponse.Validate if the designated constraints aren't met.
type SuggestionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SuggestionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SuggestionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SuggestionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SuggestionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SuggestionResponseValidationError) ErrorName() string {
	return "SuggestionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SuggestionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSuggestionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SuggestionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SuggestionResponseValidationError{}

// Validate checks the field values on SuggestionListRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SuggestionListRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SuggestionListRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SuggestionListRequestMultiError, or nil if none found.
func (m *SuggestionListRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SuggestionListRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	// no validation rules for Limit

	if len(errors) > 0 {
		return SuggestionListRequestMultiError(errors)
	}

	return nil
}

// SuggestionListRequestMultiError is an error wrapping multiple validation
// errors returned by SuggestionListRequest.ValidateAll() if the designated
// constraints aren't met.
type SuggestionListRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SuggestionListRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SuggestionListRequestMultiError) AllErrors() []error { return m }

// SuggestionListRequestValidationError is the validation error returned by
// SuggestionListRequest.Validate if the designated constraints aren't met.
type SuggestionListRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SuggestionListRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SuggestionListRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SuggestionListRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SuggestionListRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SuggestionListRequestValidationError) ErrorName() string {
	return "SuggestionListRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SuggestionListRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSuggestionListRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SuggestionListRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SuggestionListRequestValidationError{}

// Validate checks the field values on SuggestionListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SuggestionListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SuggestionListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SuggestionListResponseMultiError, or nil if none found.
func (m *SuggestionListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SuggestionListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	for idx, item := range m.GetSuggestions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SuggestionListResponseValidationError{
						field:  fmt.Sprintf("Suggestions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SuggestionListResponseValidationError{
						field:  fmt.Sprintf("Suggestions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SuggestionListResponseValidationError{
					field:  fmt.Sprintf("Suggestions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SuggestionListResponseMultiError(errors)
	}

	return nil
}

// SuggestionListResponseMultiError is an error wrapping multiple validation
// errors returned by SuggestionListResponse.ValidateAll() if the designated
// constraints aren't met.
type SuggestionListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SuggestionListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SuggestionListResponseMultiError) AllErrors() []error { return m }

// SuggestionListResponseValidationError is the validation error returned by
// SuggestionListResponse.Validate if the designated constraints aren't met.
type SuggestionListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SuggestionListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SuggestionListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SuggestionListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SuggestionListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SuggestionListResponseValidationError) ErrorName() string {
	return "SuggestionListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SuggestionListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSuggestionListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SuggestionListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SuggestionListResponseValidationError{}

// Validate checks the field values on SuggestionListByCollectionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *SuggestionListByCollectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SuggestionListByCollectionRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// SuggestionListByCollectionRequestMultiError, or nil if none found.
func (m *SuggestionListByCollectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SuggestionListByCollectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	// no validation rules for Limit

	// no validation rules for CollectionId

	if len(errors) > 0 {
		return SuggestionListByCollectionRequestMultiError(errors)
	}

	return nil
}

// SuggestionListByCollectionRequestMultiError is an error wrapping multiple
// validation errors returned by
// SuggestionListByCollectionRequest.ValidateAll() if the designated
// constraints aren't met.
type SuggestionListByCollectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SuggestionListByCollectionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SuggestionListByCollectionRequestMultiError) AllErrors() []error { return m }

// SuggestionListByCollectionRequestValidationError is the validation error
// returned by SuggestionListByCollectionRequest.Validate if the designated
// constraints aren't met.
type SuggestionListByCollectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SuggestionListByCollectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SuggestionListByCollectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SuggestionListByCollectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SuggestionListByCollectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SuggestionListByCollectionRequestValidationError) ErrorName() string {
	return "SuggestionListByCollectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SuggestionListByCollectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSuggestionListByCollectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SuggestionListByCollectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SuggestionListByCollectionRequestValidationError{}

// Validate checks the field values on SuggestionListByCollectionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *SuggestionListByCollectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SuggestionListByCollectionResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// SuggestionListByCollectionResponseMultiError, or nil if none found.
func (m *SuggestionListByCollectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SuggestionListByCollectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	for idx, item := range m.GetSuggestions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SuggestionListByCollectionResponseValidationError{
						field:  fmt.Sprintf("Suggestions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SuggestionListByCollectionResponseValidationError{
						field:  fmt.Sprintf("Suggestions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SuggestionListByCollectionResponseValidationError{
					field:  fmt.Sprintf("Suggestions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SuggestionListByCollectionResponseMultiError(errors)
	}

	return nil
}

// SuggestionListByCollectionResponseMultiError is an error wrapping multiple
// validation errors returned by
// SuggestionListByCollectionResponse.ValidateAll() if the designated
// constraints aren't met.
type SuggestionListByCollectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SuggestionListByCollectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SuggestionListByCollectionResponseMultiError) AllErrors() []error { return m }

// SuggestionListByCollectionResponseValidationError is the validation error
// returned by SuggestionListByCollectionResponse.Validate if the designated
// constraints aren't met.
type SuggestionListByCollectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SuggestionListByCollectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SuggestionListByCollectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SuggestionListByCollectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SuggestionListByCollectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SuggestionListByCollectionResponseValidationError) ErrorName() string {
	return "SuggestionListByCollectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SuggestionListByCollectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSuggestionListByCollectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SuggestionListByCollectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SuggestionListByCollectionResponseValidationError{}

// Validate checks the field values on SuggestionListByItemRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SuggestionListByItemRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SuggestionListByItemRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SuggestionListByItemRequestMultiError, or nil if none found.
func (m *SuggestionListByItemRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SuggestionListByItemRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItemKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SuggestionListByItemRequestValidationError{
					field:  "ItemKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SuggestionListByItemRequestValidationError{
					field:  "ItemKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItemKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SuggestionListByItemRequestValidationError{
				field:  "ItemKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SuggestionListByItemRequestMultiError(errors)
	}

	return nil
}

// SuggestionListByItemRequestMultiError is an error wrapping multiple
// validation errors returned by SuggestionListByItemRequest.ValidateAll() if
// the designated constraints aren't met.
type SuggestionListByItemRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SuggestionListByItemRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SuggestionListByItemRequestMultiError) AllErrors() []error { return m }

// SuggestionListByItemRequestValidationError is the validation error returned
// by SuggestionListByItemRequest.Validate if the designated constraints
// aren't met.
type SuggestionListByItemRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SuggestionListByItemRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SuggestionListByItemRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SuggestionListByItemRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SuggestionListByItemRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SuggestionListByItemRequestValidationError) ErrorName() string {
	return "SuggestionListByItemRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SuggestionListByItemRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSuggestionListByItemRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SuggestionListByItemRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SuggestionListByItemRequestValidationError{}

// Validate checks the field values on SuggestionListByItemResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SuggestionListByItemResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SuggestionListByItemResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SuggestionListByItemResponseMultiError, or nil if none found.
func (m *SuggestionListByItemResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SuggestionListByItemResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSuggestions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SuggestionListByItemResponseValidationError{
						field:  fmt.Sprintf("Suggestions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SuggestionListByItemResponseValidationError{
						field:  fmt.Sprintf("Suggestions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SuggestionListByItemResponseValidationError{
					field:  fmt.Sprintf("Suggestions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SuggestionListByItemResponseMultiError(errors)
	}

	return nil
}

// SuggestionListByItemResponseMultiError is an error wrapping multiple
// validation errors returned by SuggestionListByItemResponse.ValidateAll() if
// the designated constraints aren't met.
type SuggestionListByItemResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SuggestionListByItemResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SuggestionListByItemResponseMultiError) AllErrors() []error { return m }

// SuggestionListByItemResponseValidationError is the validation error returned
// by SuggestionListByItemResponse.Validate if the designated constraints
// aren't met.
type SuggestionListByItemResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SuggestionListByItemResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SuggestionListByItemResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SuggestionListByItemResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SuggestionListByItemResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SuggestionListByItemResponseValidationError) ErrorName() string {
	return "SuggestionListByItemResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SuggestionListByItemResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSuggestionListByItemResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SuggestionListByItemResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SuggestionListByItemResponseValidationError{}

// Validate checks the field values on SuggestionByPartialKeyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SuggestionByPartialKeyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SuggestionByPartialKeyRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SuggestionByPartialKeyRequestMultiError, or nil if none found.
func (m *SuggestionByPartialKeyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SuggestionByPartialKeyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	// no validation rules for Limit

	// no validation rules for NumAttrs

	if all {
		switch v := interface{}(m.GetItemKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SuggestionByPartialKeyRequestValidationError{
					field:  "ItemKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SuggestionByPartialKeyRequestValidationError{
					field:  "ItemKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItemKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SuggestionByPartialKeyRequestValidationError{
				field:  "ItemKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SuggestionId

	if len(errors) > 0 {
		return SuggestionByPartialKeyRequestMultiError(errors)
	}

	return nil
}

// SuggestionByPartialKeyRequestMultiError is an error wrapping multiple
// validation errors returned by SuggestionByPartialKeyRequest.ValidateAll()
// if the designated constraints aren't met.
type SuggestionByPartialKeyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SuggestionByPartialKeyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SuggestionByPartialKeyRequestMultiError) AllErrors() []error { return m }

// SuggestionByPartialKeyRequestValidationError is the validation error
// returned by SuggestionByPartialKeyRequest.Validate if the designated
// constraints aren't met.
type SuggestionByPartialKeyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SuggestionByPartialKeyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SuggestionByPartialKeyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SuggestionByPartialKeyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SuggestionByPartialKeyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SuggestionByPartialKeyRequestValidationError) ErrorName() string {
	return "SuggestionByPartialKeyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SuggestionByPartialKeyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSuggestionByPartialKeyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SuggestionByPartialKeyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SuggestionByPartialKeyRequestValidationError{}

// Validate checks the field values on SuggestionByPartialKeyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SuggestionByPartialKeyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SuggestionByPartialKeyResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SuggestionByPartialKeyResponseMultiError, or nil if none found.
func (m *SuggestionByPartialKeyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SuggestionByPartialKeyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bookmark

	for idx, item := range m.GetSuggestions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SuggestionByPartialKeyResponseValidationError{
						field:  fmt.Sprintf("Suggestions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SuggestionByPartialKeyResponseValidationError{
						field:  fmt.Sprintf("Suggestions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SuggestionByPartialKeyResponseValidationError{
					field:  fmt.Sprintf("Suggestions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SuggestionByPartialKeyResponseMultiError(errors)
	}

	return nil
}

// SuggestionByPartialKeyResponseMultiError is an error wrapping multiple
// validation errors returned by SuggestionByPartialKeyResponse.ValidateAll()
// if the designated constraints aren't met.
type SuggestionByPartialKeyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SuggestionByPartialKeyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SuggestionByPartialKeyResponseMultiError) AllErrors() []error { return m }

// SuggestionByPartialKeyResponseValidationError is the validation error
// returned by SuggestionByPartialKeyResponse.Validate if the designated
// constraints aren't met.
type SuggestionByPartialKeyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SuggestionByPartialKeyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SuggestionByPartialKeyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SuggestionByPartialKeyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SuggestionByPartialKeyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SuggestionByPartialKeyResponseValidationError) ErrorName() string {
	return "SuggestionByPartialKeyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SuggestionByPartialKeyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSuggestionByPartialKeyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SuggestionByPartialKeyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SuggestionByPartialKeyResponseValidationError{}

// Validate checks the field values on SuggestionCreateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SuggestionCreateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SuggestionCreateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SuggestionCreateRequestMultiError, or nil if none found.
func (m *SuggestionCreateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SuggestionCreateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSuggestion()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SuggestionCreateRequestValidationError{
					field:  "Suggestion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SuggestionCreateRequestValidationError{
					field:  "Suggestion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSuggestion()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SuggestionCreateRequestValidationError{
				field:  "Suggestion",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SuggestionCreateRequestMultiError(errors)
	}

	return nil
}

// SuggestionCreateRequestMultiError is an error wrapping multiple validation
// errors returned by SuggestionCreateRequest.ValidateAll() if the designated
// constraints aren't met.
type SuggestionCreateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SuggestionCreateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SuggestionCreateRequestMultiError) AllErrors() []error { return m }

// SuggestionCreateRequestValidationError is the validation error returned by
// SuggestionCreateRequest.Validate if the designated constraints aren't met.
type SuggestionCreateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SuggestionCreateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SuggestionCreateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SuggestionCreateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SuggestionCreateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SuggestionCreateRequestValidationError) ErrorName() string {
	return "SuggestionCreateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SuggestionCreateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSuggestionCreateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SuggestionCreateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SuggestionCreateRequestValidationError{}

// Validate checks the field values on SuggestionCreateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SuggestionCreateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SuggestionCreateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SuggestionCreateResponseMultiError, or nil if none found.
func (m *SuggestionCreateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SuggestionCreateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSuggestion()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SuggestionCreateResponseValidationError{
					field:  "Suggestion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SuggestionCreateResponseValidationError{
					field:  "Suggestion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSuggestion()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SuggestionCreateResponseValidationError{
				field:  "Suggestion",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SuggestionCreateResponseMultiError(errors)
	}

	return nil
}

// SuggestionCreateResponseMultiError is an error wrapping multiple validation
// errors returned by SuggestionCreateResponse.ValidateAll() if the designated
// constraints aren't met.
type SuggestionCreateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SuggestionCreateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SuggestionCreateResponseMultiError) AllErrors() []error { return m }

// SuggestionCreateResponseValidationError is the validation error returned by
// SuggestionCreateResponse.Validate if the designated constraints aren't met.
type SuggestionCreateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SuggestionCreateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SuggestionCreateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SuggestionCreateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SuggestionCreateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SuggestionCreateResponseValidationError) ErrorName() string {
	return "SuggestionCreateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SuggestionCreateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSuggestionCreateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SuggestionCreateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SuggestionCreateResponseValidationError{}

// Validate checks the field values on SuggestionDeleteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SuggestionDeleteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SuggestionDeleteRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SuggestionDeleteRequestMultiError, or nil if none found.
func (m *SuggestionDeleteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SuggestionDeleteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItemKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SuggestionDeleteRequestValidationError{
					field:  "ItemKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SuggestionDeleteRequestValidationError{
					field:  "ItemKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItemKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SuggestionDeleteRequestValidationError{
				field:  "ItemKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SuggestionId

	// no validation rules for Reason

	if len(errors) > 0 {
		return SuggestionDeleteRequestMultiError(errors)
	}

	return nil
}

// SuggestionDeleteRequestMultiError is an error wrapping multiple validation
// errors returned by SuggestionDeleteRequest.ValidateAll() if the designated
// constraints aren't met.
type SuggestionDeleteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SuggestionDeleteRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SuggestionDeleteRequestMultiError) AllErrors() []error { return m }

// SuggestionDeleteRequestValidationError is the validation error returned by
// SuggestionDeleteRequest.Validate if the designated constraints aren't met.
type SuggestionDeleteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SuggestionDeleteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SuggestionDeleteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SuggestionDeleteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SuggestionDeleteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SuggestionDeleteRequestValidationError) ErrorName() string {
	return "SuggestionDeleteRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SuggestionDeleteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSuggestionDeleteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SuggestionDeleteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SuggestionDeleteRequestValidationError{}

// Validate checks the field values on SuggestionDeleteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SuggestionDeleteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SuggestionDeleteResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SuggestionDeleteResponseMultiError, or nil if none found.
func (m *SuggestionDeleteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SuggestionDeleteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSuggestion()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SuggestionDeleteResponseValidationError{
					field:  "Suggestion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SuggestionDeleteResponseValidationError{
					field:  "Suggestion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSuggestion()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SuggestionDeleteResponseValidationError{
				field:  "Suggestion",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SuggestionDeleteResponseMultiError(errors)
	}

	return nil
}

// SuggestionDeleteResponseMultiError is an error wrapping multiple validation
// errors returned by SuggestionDeleteResponse.ValidateAll() if the designated
// constraints aren't met.
type SuggestionDeleteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SuggestionDeleteResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SuggestionDeleteResponseMultiError) AllErrors() []error { return m }

// SuggestionDeleteResponseValidationError is the validation error returned by
// SuggestionDeleteResponse.Validate if the designated constraints aren't met.
type SuggestionDeleteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SuggestionDeleteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SuggestionDeleteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SuggestionDeleteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SuggestionDeleteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SuggestionDeleteResponseValidationError) ErrorName() string {
	return "SuggestionDeleteResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SuggestionDeleteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSuggestionDeleteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SuggestionDeleteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SuggestionDeleteResponseValidationError{}

// Validate checks the field values on SuggestionApproveRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SuggestionApproveRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SuggestionApproveRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SuggestionApproveRequestMultiError, or nil if none found.
func (m *SuggestionApproveRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SuggestionApproveRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetItemKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SuggestionApproveRequestValidationError{
					field:  "ItemKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SuggestionApproveRequestValidationError{
					field:  "ItemKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItemKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SuggestionApproveRequestValidationError{
				field:  "ItemKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SuggestionId

	// no validation rules for Reason

	if len(errors) > 0 {
		return SuggestionApproveRequestMultiError(errors)
	}

	return nil
}

// SuggestionApproveRequestMultiError is an error wrapping multiple validation
// errors returned by SuggestionApproveRequest.ValidateAll() if the designated
// constraints aren't met.
type SuggestionApproveRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SuggestionApproveRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SuggestionApproveRequestMultiError) AllErrors() []error { return m }

// SuggestionApproveRequestValidationError is the validation error returned by
// SuggestionApproveRequest.Validate if the designated constraints aren't met.
type SuggestionApproveRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SuggestionApproveRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SuggestionApproveRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SuggestionApproveRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SuggestionApproveRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SuggestionApproveRequestValidationError) ErrorName() string {
	return "SuggestionApproveRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SuggestionApproveRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSuggestionApproveRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SuggestionApproveRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SuggestionApproveRequestValidationError{}

// Validate checks the field values on SuggestionApproveResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SuggestionApproveResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SuggestionApproveResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SuggestionApproveResponseMultiError, or nil if none found.
func (m *SuggestionApproveResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SuggestionApproveResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSuggestion()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SuggestionApproveResponseValidationError{
					field:  "Suggestion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SuggestionApproveResponseValidationError{
					field:  "Suggestion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSuggestion()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SuggestionApproveResponseValidationError{
				field:  "Suggestion",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SuggestionApproveResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SuggestionApproveResponseValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SuggestionApproveResponseValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SuggestionApproveResponseMultiError(errors)
	}

	return nil
}

// SuggestionApproveResponseMultiError is an error wrapping multiple validation
// errors returned by SuggestionApproveResponse.ValidateAll() if the
// designated constraints aren't met.
type SuggestionApproveResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SuggestionApproveResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SuggestionApproveResponseMultiError) AllErrors() []error { return m }

// SuggestionApproveResponseValidationError is the validation error returned by
// SuggestionApproveResponse.Validate if the designated constraints aren't met.
type SuggestionApproveResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SuggestionApproveResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SuggestionApproveResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SuggestionApproveResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SuggestionApproveResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SuggestionApproveResponseValidationError) ErrorName() string {
	return "SuggestionApproveResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SuggestionApproveResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSuggestionApproveResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SuggestionApproveResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SuggestionApproveResponseValidationError{}
