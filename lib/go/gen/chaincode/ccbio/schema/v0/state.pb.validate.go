// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: chaincode/ccbio/schema/v0/state.proto

package v0

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Specimen with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Specimen) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Specimen with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SpecimenMultiError, or nil
// if none found.
func (m *Specimen) ValidateAll() error {
	return m.validate(true)
}

func (m *Specimen) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CollectionId

	// no validation rules for SpecimenId

	if all {
		switch v := interface{}(m.GetPrimary()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SpecimenValidationError{
					field:  "Primary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SpecimenValidationError{
					field:  "Primary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrimary()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SpecimenValidationError{
				field:  "Primary",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSecondary()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SpecimenValidationError{
					field:  "Secondary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SpecimenValidationError{
					field:  "Secondary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecondary()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SpecimenValidationError{
				field:  "Secondary",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTaxon()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SpecimenValidationError{
					field:  "Taxon",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SpecimenValidationError{
					field:  "Taxon",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaxon()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SpecimenValidationError{
				field:  "Taxon",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGeoreference()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SpecimenValidationError{
					field:  "Georeference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SpecimenValidationError{
					field:  "Georeference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGeoreference()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SpecimenValidationError{
				field:  "Georeference",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetImages()))
		i := 0
		for key := range m.GetImages() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetImages()[key]
			_ = val

			// no validation rules for Images[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, SpecimenValidationError{
							field:  fmt.Sprintf("Images[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, SpecimenValidationError{
							field:  fmt.Sprintf("Images[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return SpecimenValidationError{
						field:  fmt.Sprintf("Images[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetLoans()))
		i := 0
		for key := range m.GetLoans() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetLoans()[key]
			_ = val

			// no validation rules for Loans[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, SpecimenValidationError{
							field:  fmt.Sprintf("Loans[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, SpecimenValidationError{
							field:  fmt.Sprintf("Loans[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return SpecimenValidationError{
						field:  fmt.Sprintf("Loans[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetGrants()))
		i := 0
		for key := range m.GetGrants() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetGrants()[key]
			_ = val

			// no validation rules for Grants[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, SpecimenValidationError{
							field:  fmt.Sprintf("Grants[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, SpecimenValidationError{
							field:  fmt.Sprintf("Grants[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return SpecimenValidationError{
						field:  fmt.Sprintf("Grants[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return SpecimenMultiError(errors)
	}

	return nil
}

// SpecimenMultiError is an error wrapping multiple validation errors returned
// by Specimen.ValidateAll() if the designated constraints aren't met.
type SpecimenMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpecimenMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpecimenMultiError) AllErrors() []error { return m }

// SpecimenValidationError is the validation error returned by
// Specimen.Validate if the designated constraints aren't met.
type SpecimenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpecimenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpecimenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpecimenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpecimenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpecimenValidationError) ErrorName() string { return "SpecimenValidationError" }

// Error satisfies the builtin error interface
func (e SpecimenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecimen.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpecimenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpecimenValidationError{}

// Validate checks the field values on Specimen_Primary with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Specimen_Primary) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Specimen_Primary with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Specimen_PrimaryMultiError, or nil if none found.
func (m *Specimen_Primary) ValidateAll() error {
	return m.validate(true)
}

func (m *Specimen_Primary) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CatalogNumber

	// no validation rules for AccessionNumber

	// no validation rules for FieldNumber

	// no validation rules for TissueNumber

	// no validation rules for Cataloger

	// no validation rules for Collector

	// no validation rules for Determiner

	if all {
		switch v := interface{}(m.GetFieldDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_PrimaryValidationError{
					field:  "FieldDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_PrimaryValidationError{
					field:  "FieldDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFieldDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_PrimaryValidationError{
				field:  "FieldDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCatalogDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_PrimaryValidationError{
					field:  "CatalogDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_PrimaryValidationError{
					field:  "CatalogDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCatalogDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_PrimaryValidationError{
				field:  "CatalogDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeterminedDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_PrimaryValidationError{
					field:  "DeterminedDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_PrimaryValidationError{
					field:  "DeterminedDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeterminedDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_PrimaryValidationError{
				field:  "DeterminedDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DeterminedReason

	if all {
		switch v := interface{}(m.GetLastModified()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_PrimaryValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_PrimaryValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastModified()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_PrimaryValidationError{
				field:  "LastModified",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Specimen_PrimaryMultiError(errors)
	}

	return nil
}

// Specimen_PrimaryMultiError is an error wrapping multiple validation errors
// returned by Specimen_Primary.ValidateAll() if the designated constraints
// aren't met.
type Specimen_PrimaryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Specimen_PrimaryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Specimen_PrimaryMultiError) AllErrors() []error { return m }

// Specimen_PrimaryValidationError is the validation error returned by
// Specimen_Primary.Validate if the designated constraints aren't met.
type Specimen_PrimaryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Specimen_PrimaryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Specimen_PrimaryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Specimen_PrimaryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Specimen_PrimaryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Specimen_PrimaryValidationError) ErrorName() string { return "Specimen_PrimaryValidationError" }

// Error satisfies the builtin error interface
func (e Specimen_PrimaryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecimen_Primary.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Specimen_PrimaryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Specimen_PrimaryValidationError{}

// Validate checks the field values on Specimen_Secondary with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Specimen_Secondary) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Specimen_Secondary with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Specimen_SecondaryMultiError, or nil if none found.
func (m *Specimen_Secondary) ValidateAll() error {
	return m.validate(true)
}

func (m *Specimen_Secondary) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Preparation

	// no validation rules for Condition

	// no validation rules for Notes

	if all {
		switch v := interface{}(m.GetLastModified()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_SecondaryValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_SecondaryValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastModified()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_SecondaryValidationError{
				field:  "LastModified",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Specimen_SecondaryMultiError(errors)
	}

	return nil
}

// Specimen_SecondaryMultiError is an error wrapping multiple validation errors
// returned by Specimen_Secondary.ValidateAll() if the designated constraints
// aren't met.
type Specimen_SecondaryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Specimen_SecondaryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Specimen_SecondaryMultiError) AllErrors() []error { return m }

// Specimen_SecondaryValidationError is the validation error returned by
// Specimen_Secondary.Validate if the designated constraints aren't met.
type Specimen_SecondaryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Specimen_SecondaryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Specimen_SecondaryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Specimen_SecondaryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Specimen_SecondaryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Specimen_SecondaryValidationError) ErrorName() string {
	return "Specimen_SecondaryValidationError"
}

// Error satisfies the builtin error interface
func (e Specimen_SecondaryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecimen_Secondary.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Specimen_SecondaryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Specimen_SecondaryValidationError{}

// Validate checks the field values on Specimen_Taxon with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Specimen_Taxon) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Specimen_Taxon with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Specimen_TaxonMultiError,
// or nil if none found.
func (m *Specimen_Taxon) ValidateAll() error {
	return m.validate(true)
}

func (m *Specimen_Taxon) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kingdom

	// no validation rules for Phylum

	// no validation rules for Class

	// no validation rules for Order

	// no validation rules for Family

	// no validation rules for Genus

	// no validation rules for Species

	// no validation rules for Subspecies

	if all {
		switch v := interface{}(m.GetLastModified()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_TaxonValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_TaxonValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastModified()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_TaxonValidationError{
				field:  "LastModified",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Specimen_TaxonMultiError(errors)
	}

	return nil
}

// Specimen_TaxonMultiError is an error wrapping multiple validation errors
// returned by Specimen_Taxon.ValidateAll() if the designated constraints
// aren't met.
type Specimen_TaxonMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Specimen_TaxonMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Specimen_TaxonMultiError) AllErrors() []error { return m }

// Specimen_TaxonValidationError is the validation error returned by
// Specimen_Taxon.Validate if the designated constraints aren't met.
type Specimen_TaxonValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Specimen_TaxonValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Specimen_TaxonValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Specimen_TaxonValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Specimen_TaxonValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Specimen_TaxonValidationError) ErrorName() string { return "Specimen_TaxonValidationError" }

// Error satisfies the builtin error interface
func (e Specimen_TaxonValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecimen_Taxon.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Specimen_TaxonValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Specimen_TaxonValidationError{}

// Validate checks the field values on Specimen_Georeference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Specimen_Georeference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Specimen_Georeference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Specimen_GeoreferenceMultiError, or nil if none found.
func (m *Specimen_Georeference) ValidateAll() error {
	return m.validate(true)
}

func (m *Specimen_Georeference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Country

	// no validation rules for StateProvince

	// no validation rules for County

	// no validation rules for Locality

	// no validation rules for Latitude

	// no validation rules for Longitude

	// no validation rules for Habitat

	if all {
		switch v := interface{}(m.GetLastModified()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_GeoreferenceValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_GeoreferenceValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastModified()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_GeoreferenceValidationError{
				field:  "LastModified",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Specimen_GeoreferenceMultiError(errors)
	}

	return nil
}

// Specimen_GeoreferenceMultiError is an error wrapping multiple validation
// errors returned by Specimen_Georeference.ValidateAll() if the designated
// constraints aren't met.
type Specimen_GeoreferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Specimen_GeoreferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Specimen_GeoreferenceMultiError) AllErrors() []error { return m }

// Specimen_GeoreferenceValidationError is the validation error returned by
// Specimen_Georeference.Validate if the designated constraints aren't met.
type Specimen_GeoreferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Specimen_GeoreferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Specimen_GeoreferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Specimen_GeoreferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Specimen_GeoreferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Specimen_GeoreferenceValidationError) ErrorName() string {
	return "Specimen_GeoreferenceValidationError"
}

// Error satisfies the builtin error interface
func (e Specimen_GeoreferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecimen_Georeference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Specimen_GeoreferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Specimen_GeoreferenceValidationError{}

// Validate checks the field values on Specimen_Image with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Specimen_Image) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Specimen_Image with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Specimen_ImageMultiError,
// or nil if none found.
func (m *Specimen_Image) ValidateAll() error {
	return m.validate(true)
}

func (m *Specimen_Image) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Url

	// no validation rules for Notes

	// no validation rules for Hash

	if all {
		switch v := interface{}(m.GetLastModified()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_ImageValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_ImageValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastModified()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_ImageValidationError{
				field:  "LastModified",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Specimen_ImageMultiError(errors)
	}

	return nil
}

// Specimen_ImageMultiError is an error wrapping multiple validation errors
// returned by Specimen_Image.ValidateAll() if the designated constraints
// aren't met.
type Specimen_ImageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Specimen_ImageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Specimen_ImageMultiError) AllErrors() []error { return m }

// Specimen_ImageValidationError is the validation error returned by
// Specimen_Image.Validate if the designated constraints aren't met.
type Specimen_ImageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Specimen_ImageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Specimen_ImageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Specimen_ImageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Specimen_ImageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Specimen_ImageValidationError) ErrorName() string { return "Specimen_ImageValidationError" }

// Error satisfies the builtin error interface
func (e Specimen_ImageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecimen_Image.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Specimen_ImageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Specimen_ImageValidationError{}

// Validate checks the field values on Specimen_Loan with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Specimen_Loan) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Specimen_Loan with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Specimen_LoanMultiError, or
// nil if none found.
func (m *Specimen_Loan) ValidateAll() error {
	return m.validate(true)
}

func (m *Specimen_Loan) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Description

	// no validation rules for LoanedBy

	// no validation rules for LoanedTo

	if all {
		switch v := interface{}(m.GetLoanedDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_LoanValidationError{
					field:  "LoanedDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_LoanValidationError{
					field:  "LoanedDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLoanedDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_LoanValidationError{
				field:  "LoanedDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastModified()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_LoanValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_LoanValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastModified()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_LoanValidationError{
				field:  "LastModified",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Specimen_LoanMultiError(errors)
	}

	return nil
}

// Specimen_LoanMultiError is an error wrapping multiple validation errors
// returned by Specimen_Loan.ValidateAll() if the designated constraints
// aren't met.
type Specimen_LoanMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Specimen_LoanMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Specimen_LoanMultiError) AllErrors() []error { return m }

// Specimen_LoanValidationError is the validation error returned by
// Specimen_Loan.Validate if the designated constraints aren't met.
type Specimen_LoanValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Specimen_LoanValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Specimen_LoanValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Specimen_LoanValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Specimen_LoanValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Specimen_LoanValidationError) ErrorName() string { return "Specimen_LoanValidationError" }

// Error satisfies the builtin error interface
func (e Specimen_LoanValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecimen_Loan.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Specimen_LoanValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Specimen_LoanValidationError{}

// Validate checks the field values on Specimen_Grant with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Specimen_Grant) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Specimen_Grant with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Specimen_GrantMultiError,
// or nil if none found.
func (m *Specimen_Grant) ValidateAll() error {
	return m.validate(true)
}

func (m *Specimen_Grant) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Description

	// no validation rules for GrantedBy

	// no validation rules for GrantedTo

	if all {
		switch v := interface{}(m.GetGrantedDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_GrantValidationError{
					field:  "GrantedDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_GrantValidationError{
					field:  "GrantedDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGrantedDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_GrantValidationError{
				field:  "GrantedDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastModified()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_GrantValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_GrantValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastModified()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_GrantValidationError{
				field:  "LastModified",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Specimen_GrantMultiError(errors)
	}

	return nil
}

// Specimen_GrantMultiError is an error wrapping multiple validation errors
// returned by Specimen_Grant.ValidateAll() if the designated constraints
// aren't met.
type Specimen_GrantMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Specimen_GrantMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Specimen_GrantMultiError) AllErrors() []error { return m }

// Specimen_GrantValidationError is the validation error returned by
// Specimen_Grant.Validate if the designated constraints aren't met.
type Specimen_GrantValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Specimen_GrantValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Specimen_GrantValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Specimen_GrantValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Specimen_GrantValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Specimen_GrantValidationError) ErrorName() string { return "Specimen_GrantValidationError" }

// Error satisfies the builtin error interface
func (e Specimen_GrantValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecimen_Grant.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Specimen_GrantValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Specimen_GrantValidationError{}
