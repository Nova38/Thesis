// Code generated by protoc-gen-go-hlf. DO NOT EDIT.
// versions:
// - protoc-gen-cckey v0.0.1
// source: chaincode/ccbio/schema/v2/state.proto

package schemav2

func (m *LastModified) DiffPath(other *LastModified) (updated []string, all bool) {

	all = true
	// user_id: is a message
	if m.UserId != nil || other.UserId != nil {
		updated_UserId, all_UserId := m.UserId.DiffPath(other.UserId)
		if len(updated_UserId) > 0 {
			if all_UserId {
				updated = append(updated, "user_id")
			} else {
				for _, u := range updated_UserId {
					updated = append(updated, "user_id."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// user_name: is a string
	if m.UserName != other.UserName {
		updated = append(updated, "user_name")
	} else {
		all = false
	}
	// tx_id: is a string
	if m.TxId != other.TxId {
		updated = append(updated, "tx_id")
	} else {
		all = false
	}
	// updated_at: is a message

	return updated, all
}

func (m *Action) DiffPath(other *Action) (updated []string, all bool) {

	all = true
	// level: is a enum
	if m.Level != other.Level {
		updated = append(updated, "level")
	} else {
		all = false
	}
	// domains: is a enum
	// TODO: Handle lists

	return updated, all
}

func (m *Collection_Id) DiffPath(other *Collection_Id) (updated []string, all bool) {

	all = true
	// collection_id: is a string
	if m.CollectionId != other.CollectionId {
		updated = append(updated, "collection_id")
	} else {
		all = false
	}

	return updated, all
}

func (m *Collection_List) DiffPath(other *Collection_List) (updated []string, all bool) {

	all = true
	// items: is a message
	// TODO: Handle lists

	return updated, all
}

func (m *Collection_AccessControl_AccessControlActions) DiffPath(other *Collection_AccessControl_AccessControlActions) (updated []string, all bool) {

	all = true
	// view: is a enum
	// TODO: Handle lists
	// edit: is a enum
	// TODO: Handle lists

	return updated, all
}

func (m *Collection_AccessControl_SpecimenActions) DiffPath(other *Collection_AccessControl_SpecimenActions) (updated []string, all bool) {

	all = true
	// view: is a enum
	// TODO: Handle lists
	// create: is a enum
	// TODO: Handle lists
	// delete: is a enum
	// TODO: Handle lists
	// hide_tx: is a enum
	// TODO: Handle lists

	return updated, all
}

func (m *Collection_AccessControl_SectionActions) DiffPath(other *Collection_AccessControl_SectionActions) (updated []string, all bool) {

	all = true
	// view: is a enum
	// TODO: Handle lists
	// edit: is a enum
	// TODO: Handle lists
	// suggest_edit: is a enum
	// TODO: Handle lists
	// suggest_approve: is a enum
	// TODO: Handle lists
	// suggest_reject: is a enum
	// TODO: Handle lists

	return updated, all
}

func (m *Collection_AccessControl) DiffPath(other *Collection_AccessControl) (updated []string, all bool) {

	all = true
	// roles: is a message
	if m.Roles != nil || other.Roles != nil {
		updated_Roles, all_Roles := m.Roles.DiffPath(other.Roles)
		if len(updated_Roles) > 0 {
			if all_Roles {
				updated = append(updated, "roles")
			} else {
				for _, u := range updated_Roles {
					updated = append(updated, "roles."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// users: is a message
	if m.Users != nil || other.Users != nil {
		updated_Users, all_Users := m.Users.DiffPath(other.Users)
		if len(updated_Users) > 0 {
			if all_Users {
				updated = append(updated, "users")
			} else {
				for _, u := range updated_Users {
					updated = append(updated, "users."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// specimen: is a message
	if m.Specimen != nil || other.Specimen != nil {
		updated_Specimen, all_Specimen := m.Specimen.DiffPath(other.Specimen)
		if len(updated_Specimen) > 0 {
			if all_Specimen {
				updated = append(updated, "specimen")
			} else {
				for _, u := range updated_Specimen {
					updated = append(updated, "specimen."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// primary: is a message
	if m.Primary != nil || other.Primary != nil {
		updated_Primary, all_Primary := m.Primary.DiffPath(other.Primary)
		if len(updated_Primary) > 0 {
			if all_Primary {
				updated = append(updated, "primary")
			} else {
				for _, u := range updated_Primary {
					updated = append(updated, "primary."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// secondary: is a message
	if m.Secondary != nil || other.Secondary != nil {
		updated_Secondary, all_Secondary := m.Secondary.DiffPath(other.Secondary)
		if len(updated_Secondary) > 0 {
			if all_Secondary {
				updated = append(updated, "secondary")
			} else {
				for _, u := range updated_Secondary {
					updated = append(updated, "secondary."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// taxon: is a message
	if m.Taxon != nil || other.Taxon != nil {
		updated_Taxon, all_Taxon := m.Taxon.DiffPath(other.Taxon)
		if len(updated_Taxon) > 0 {
			if all_Taxon {
				updated = append(updated, "taxon")
			} else {
				for _, u := range updated_Taxon {
					updated = append(updated, "taxon."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// georeference: is a message
	if m.Georeference != nil || other.Georeference != nil {
		updated_Georeference, all_Georeference := m.Georeference.DiffPath(other.Georeference)
		if len(updated_Georeference) > 0 {
			if all_Georeference {
				updated = append(updated, "georeference")
			} else {
				for _, u := range updated_Georeference {
					updated = append(updated, "georeference."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// images: is a message
	if m.Images != nil || other.Images != nil {
		updated_Images, all_Images := m.Images.DiffPath(other.Images)
		if len(updated_Images) > 0 {
			if all_Images {
				updated = append(updated, "images")
			} else {
				for _, u := range updated_Images {
					updated = append(updated, "images."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// loans: is a message
	if m.Loans != nil || other.Loans != nil {
		updated_Loans, all_Loans := m.Loans.DiffPath(other.Loans)
		if len(updated_Loans) > 0 {
			if all_Loans {
				updated = append(updated, "loans")
			} else {
				for _, u := range updated_Loans {
					updated = append(updated, "loans."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// grants: is a message
	if m.Grants != nil || other.Grants != nil {
		updated_Grants, all_Grants := m.Grants.DiffPath(other.Grants)
		if len(updated_Grants) > 0 {
			if all_Grants {
				updated = append(updated, "grants")
			} else {
				for _, u := range updated_Grants {
					updated = append(updated, "grants."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}

	return updated, all
}

func (m *Collection) DiffPath(other *Collection) (updated []string, all bool) {

	all = true
	// id: is a message
	if m.Id != nil || other.Id != nil {
		updated_Id, all_Id := m.Id.DiffPath(other.Id)
		if len(updated_Id) > 0 {
			if all_Id {
				updated = append(updated, "id")
			} else {
				for _, u := range updated_Id {
					updated = append(updated, "id."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// access_control: is a message
	if m.AccessControl != nil || other.AccessControl != nil {
		updated_AccessControl, all_AccessControl := m.AccessControl.DiffPath(other.AccessControl)
		if len(updated_AccessControl) > 0 {
			if all_AccessControl {
				updated = append(updated, "access_control")
			} else {
				for _, u := range updated_AccessControl {
					updated = append(updated, "access_control."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}

	return updated, all
}

func (m *CollectionList) DiffPath(other *CollectionList) (updated []string, all bool) {

	all = true
	// items: is a message
	// TODO: Handle lists

	return updated, all
}

func (m *User_Id) DiffPath(other *User_Id) (updated []string, all bool) {

	all = true
	// msp_id: is a string
	if m.MspId != other.MspId {
		updated = append(updated, "msp_id")
	} else {
		all = false
	}
	// id: is a string
	if m.Id != other.Id {
		updated = append(updated, "id")
	} else {
		all = false
	}

	return updated, all
}

func (m *User_List) DiffPath(other *User_List) (updated []string, all bool) {

	all = true
	// items: is a message
	// TODO: Handle lists

	return updated, all
}

func (m *User) DiffPath(other *User) (updated []string, all bool) {

	all = true
	// id: is a message
	if m.Id != nil || other.Id != nil {
		updated_Id, all_Id := m.Id.DiffPath(other.Id)
		if len(updated_Id) > 0 {
			if all_Id {
				updated = append(updated, "id")
			} else {
				for _, u := range updated_Id {
					updated = append(updated, "id."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// name: is a string
	if m.Name != other.Name {
		updated = append(updated, "name")
	} else {
		all = false
	}
	// email: is a string
	if m.Email != other.Email {
		updated = append(updated, "email")
	} else {
		all = false
	}
	// affiliation: is a string
	if m.Affiliation != other.Affiliation {
		updated = append(updated, "affiliation")
	} else {
		all = false
	}
	// memberships: is a message
	// TODO: Handle maps

	return updated, all
}

func (m *Specimen_Id) DiffPath(other *Specimen_Id) (updated []string, all bool) {

	all = true
	// collection_id: is a string
	if m.CollectionId != other.CollectionId {
		updated = append(updated, "collection_id")
	} else {
		all = false
	}
	// id: is a string
	if m.Id != other.Id {
		updated = append(updated, "id")
	} else {
		all = false
	}

	return updated, all
}

func (m *Specimen_List) DiffPath(other *Specimen_List) (updated []string, all bool) {

	all = true
	// items: is a message
	// TODO: Handle lists

	return updated, all
}

func (m *Specimen_History_Entry) DiffPath(other *Specimen_History_Entry) (updated []string, all bool) {

	all = true
	// tx_id: is a string
	if m.TxId != other.TxId {
		updated = append(updated, "tx_id")
	} else {
		all = false
	}
	// timestamp: is a message
	// is_deleted: is a bool
	if m.IsDeleted != other.IsDeleted {
		updated = append(updated, "is_deleted")
	} else {
		all = false
	}
	// is_hidden: is a bool
	if m.IsHidden != other.IsHidden {
		updated = append(updated, "is_hidden")
	} else {
		all = false
	}
	// state: is a message
	if m.State != nil || other.State != nil {
		updated_State, all_State := m.State.DiffPath(other.State)
		if len(updated_State) > 0 {
			if all_State {
				updated = append(updated, "state")
			} else {
				for _, u := range updated_State {
					updated = append(updated, "state."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}

	return updated, all
}

func (m *Specimen_History) DiffPath(other *Specimen_History) (updated []string, all bool) {

	all = true
	// id: is a message
	if m.Id != nil || other.Id != nil {
		updated_Id, all_Id := m.Id.DiffPath(other.Id)
		if len(updated_Id) > 0 {
			if all_Id {
				updated = append(updated, "id")
			} else {
				for _, u := range updated_Id {
					updated = append(updated, "id."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// entries: is a message
	// TODO: Handle lists

	return updated, all
}

func (m *Specimen_Primary) DiffPath(other *Specimen_Primary) (updated []string, all bool) {

	all = true
	// catalog_number: is a string
	if m.CatalogNumber != other.CatalogNumber {
		updated = append(updated, "catalog_number")
	} else {
		all = false
	}
	// accession_number: is a string
	if m.AccessionNumber != other.AccessionNumber {
		updated = append(updated, "accession_number")
	} else {
		all = false
	}
	// field_number: is a string
	if m.FieldNumber != other.FieldNumber {
		updated = append(updated, "field_number")
	} else {
		all = false
	}
	// tissue_number: is a string
	if m.TissueNumber != other.TissueNumber {
		updated = append(updated, "tissue_number")
	} else {
		all = false
	}
	// cataloger: is a string
	if m.Cataloger != other.Cataloger {
		updated = append(updated, "cataloger")
	} else {
		all = false
	}
	// collector: is a string
	if m.Collector != other.Collector {
		updated = append(updated, "collector")
	} else {
		all = false
	}
	// determiner: is a string
	if m.Determiner != other.Determiner {
		updated = append(updated, "determiner")
	} else {
		all = false
	}
	// field_date: is a message
	// catalog_date: is a message
	// determined_date: is a message
	// determined_reason: is a string
	if m.DeterminedReason != other.DeterminedReason {
		updated = append(updated, "determined_reason")
	} else {
		all = false
	}
	// last_modified: is a message
	if m.LastModified != nil || other.LastModified != nil {
		updated_LastModified, all_LastModified := m.LastModified.DiffPath(other.LastModified)
		if len(updated_LastModified) > 0 {
			if all_LastModified {
				updated = append(updated, "last_modified")
			} else {
				for _, u := range updated_LastModified {
					updated = append(updated, "last_modified."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}

	return updated, all
}

func (m *Specimen_Secondary) DiffPath(other *Specimen_Secondary) (updated []string, all bool) {

	all = true
	// preparation: is a string
	if m.Preparation != other.Preparation {
		updated = append(updated, "preparation")
	} else {
		all = false
	}
	// condition: is a string
	if m.Condition != other.Condition {
		updated = append(updated, "condition")
	} else {
		all = false
	}
	// notes: is a string
	if m.Notes != other.Notes {
		updated = append(updated, "notes")
	} else {
		all = false
	}
	// last_modified: is a message
	if m.LastModified != nil || other.LastModified != nil {
		updated_LastModified, all_LastModified := m.LastModified.DiffPath(other.LastModified)
		if len(updated_LastModified) > 0 {
			if all_LastModified {
				updated = append(updated, "last_modified")
			} else {
				for _, u := range updated_LastModified {
					updated = append(updated, "last_modified."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}

	return updated, all
}

func (m *Specimen_Taxon) DiffPath(other *Specimen_Taxon) (updated []string, all bool) {

	all = true
	// kingdom: is a string
	if m.Kingdom != other.Kingdom {
		updated = append(updated, "kingdom")
	} else {
		all = false
	}
	// phylum: is a string
	if m.Phylum != other.Phylum {
		updated = append(updated, "phylum")
	} else {
		all = false
	}
	// class: is a string
	if m.Class != other.Class {
		updated = append(updated, "class")
	} else {
		all = false
	}
	// order: is a string
	if m.Order != other.Order {
		updated = append(updated, "order")
	} else {
		all = false
	}
	// family: is a string
	if m.Family != other.Family {
		updated = append(updated, "family")
	} else {
		all = false
	}
	// genus: is a string
	if m.Genus != other.Genus {
		updated = append(updated, "genus")
	} else {
		all = false
	}
	// species: is a string
	if m.Species != other.Species {
		updated = append(updated, "species")
	} else {
		all = false
	}
	// subspecies: is a string
	if m.Subspecies != other.Subspecies {
		updated = append(updated, "subspecies")
	} else {
		all = false
	}
	// last_modified: is a message
	if m.LastModified != nil || other.LastModified != nil {
		updated_LastModified, all_LastModified := m.LastModified.DiffPath(other.LastModified)
		if len(updated_LastModified) > 0 {
			if all_LastModified {
				updated = append(updated, "last_modified")
			} else {
				for _, u := range updated_LastModified {
					updated = append(updated, "last_modified."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}

	return updated, all
}

func (m *Specimen_Georeference) DiffPath(other *Specimen_Georeference) (updated []string, all bool) {

	all = true
	// country: is a string
	if m.Country != other.Country {
		updated = append(updated, "country")
	} else {
		all = false
	}
	// state_province: is a string
	if m.StateProvince != other.StateProvince {
		updated = append(updated, "state_province")
	} else {
		all = false
	}
	// county: is a string
	if m.County != other.County {
		updated = append(updated, "county")
	} else {
		all = false
	}
	// locality: is a string
	if m.Locality != other.Locality {
		updated = append(updated, "locality")
	} else {
		all = false
	}
	// latitude: is a string
	if m.Latitude != other.Latitude {
		updated = append(updated, "latitude")
	} else {
		all = false
	}
	// longitude: is a string
	if m.Longitude != other.Longitude {
		updated = append(updated, "longitude")
	} else {
		all = false
	}
	// habitat: is a string
	if m.Habitat != other.Habitat {
		updated = append(updated, "habitat")
	} else {
		all = false
	}
	// notes: is a string
	// TODO: Handle lists
	// last_modified: is a message
	if m.LastModified != nil || other.LastModified != nil {
		updated_LastModified, all_LastModified := m.LastModified.DiffPath(other.LastModified)
		if len(updated_LastModified) > 0 {
			if all_LastModified {
				updated = append(updated, "last_modified")
			} else {
				for _, u := range updated_LastModified {
					updated = append(updated, "last_modified."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}

	return updated, all
}

func (m *Specimen_Image) DiffPath(other *Specimen_Image) (updated []string, all bool) {

	all = true
	// id: is a string
	if m.Id != other.Id {
		updated = append(updated, "id")
	} else {
		all = false
	}
	// url: is a string
	if m.Url != other.Url {
		updated = append(updated, "url")
	} else {
		all = false
	}
	// notes: is a string
	if m.Notes != other.Notes {
		updated = append(updated, "notes")
	} else {
		all = false
	}
	// hash: is a string
	if m.Hash != other.Hash {
		updated = append(updated, "hash")
	} else {
		all = false
	}
	// last_modified: is a message
	if m.LastModified != nil || other.LastModified != nil {
		updated_LastModified, all_LastModified := m.LastModified.DiffPath(other.LastModified)
		if len(updated_LastModified) > 0 {
			if all_LastModified {
				updated = append(updated, "last_modified")
			} else {
				for _, u := range updated_LastModified {
					updated = append(updated, "last_modified."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}

	return updated, all
}

func (m *Specimen_HiddenTx) DiffPath(other *Specimen_HiddenTx) (updated []string, all bool) {

	all = true
	// tx_id: is a string
	if m.TxId != other.TxId {
		updated = append(updated, "tx_id")
	} else {
		all = false
	}
	// notes: is a string
	if m.Notes != other.Notes {
		updated = append(updated, "notes")
	} else {
		all = false
	}
	// last_modified: is a message
	if m.LastModified != nil || other.LastModified != nil {
		updated_LastModified, all_LastModified := m.LastModified.DiffPath(other.LastModified)
		if len(updated_LastModified) > 0 {
			if all_LastModified {
				updated = append(updated, "last_modified")
			} else {
				for _, u := range updated_LastModified {
					updated = append(updated, "last_modified."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}

	return updated, all
}

func (m *Specimen) DiffPath(other *Specimen) (updated []string, all bool) {

	all = true
	// id: is a message
	if m.Id != nil || other.Id != nil {
		updated_Id, all_Id := m.Id.DiffPath(other.Id)
		if len(updated_Id) > 0 {
			if all_Id {
				updated = append(updated, "id")
			} else {
				for _, u := range updated_Id {
					updated = append(updated, "id."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// primary: is a message
	if m.Primary != nil || other.Primary != nil {
		updated_Primary, all_Primary := m.Primary.DiffPath(other.Primary)
		if len(updated_Primary) > 0 {
			if all_Primary {
				updated = append(updated, "primary")
			} else {
				for _, u := range updated_Primary {
					updated = append(updated, "primary."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// secondary: is a message
	if m.Secondary != nil || other.Secondary != nil {
		updated_Secondary, all_Secondary := m.Secondary.DiffPath(other.Secondary)
		if len(updated_Secondary) > 0 {
			if all_Secondary {
				updated = append(updated, "secondary")
			} else {
				for _, u := range updated_Secondary {
					updated = append(updated, "secondary."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// taxon: is a message
	if m.Taxon != nil || other.Taxon != nil {
		updated_Taxon, all_Taxon := m.Taxon.DiffPath(other.Taxon)
		if len(updated_Taxon) > 0 {
			if all_Taxon {
				updated = append(updated, "taxon")
			} else {
				for _, u := range updated_Taxon {
					updated = append(updated, "taxon."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// georeference: is a message
	if m.Georeference != nil || other.Georeference != nil {
		updated_Georeference, all_Georeference := m.Georeference.DiffPath(other.Georeference)
		if len(updated_Georeference) > 0 {
			if all_Georeference {
				updated = append(updated, "georeference")
			} else {
				for _, u := range updated_Georeference {
					updated = append(updated, "georeference."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// images: is a message
	// TODO: Handle maps
	// loans: is a string
	if m.Loans != other.Loans {
		updated = append(updated, "loans")
	} else {
		all = false
	}
	// grants: is a string
	if m.Grants != other.Grants {
		updated = append(updated, "grants")
	} else {
		all = false
	}
	// hidden_txs: is a message
	// TODO: Handle maps
	// last_modified: is a message
	if m.LastModified != nil || other.LastModified != nil {
		updated_LastModified, all_LastModified := m.LastModified.DiffPath(other.LastModified)
		if len(updated_LastModified) > 0 {
			if all_LastModified {
				updated = append(updated, "last_modified")
			} else {
				for _, u := range updated_LastModified {
					updated = append(updated, "last_modified."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}

	return updated, all
}

func (m *SuggestedUpdate_Id) DiffPath(other *SuggestedUpdate_Id) (updated []string, all bool) {

	all = true
	// specimen_id: is a message
	if m.SpecimenId != nil || other.SpecimenId != nil {
		updated_SpecimenId, all_SpecimenId := m.SpecimenId.DiffPath(other.SpecimenId)
		if len(updated_SpecimenId) > 0 {
			if all_SpecimenId {
				updated = append(updated, "specimen_id")
			} else {
				for _, u := range updated_SpecimenId {
					updated = append(updated, "specimen_id."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// id: is a string
	if m.Id != other.Id {
		updated = append(updated, "id")
	} else {
		all = false
	}

	return updated, all
}

func (m *SuggestedUpdate) DiffPath(other *SuggestedUpdate) (updated []string, all bool) {

	all = true
	// id: is a message
	if m.Id != nil || other.Id != nil {
		updated_Id, all_Id := m.Id.DiffPath(other.Id)
		if len(updated_Id) > 0 {
			if all_Id {
				updated = append(updated, "id")
			} else {
				for _, u := range updated_Id {
					updated = append(updated, "id."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// suggested_by: is a message
	if m.SuggestedBy != nil || other.SuggestedBy != nil {
		updated_SuggestedBy, all_SuggestedBy := m.SuggestedBy.DiffPath(other.SuggestedBy)
		if len(updated_SuggestedBy) > 0 {
			if all_SuggestedBy {
				updated = append(updated, "suggested_by")
			} else {
				for _, u := range updated_SuggestedBy {
					updated = append(updated, "suggested_by."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// suggested_date: is a message
	// suggested_reason: is a string
	if m.SuggestedReason != other.SuggestedReason {
		updated = append(updated, "suggested_reason")
	} else {
		all = false
	}
	// primary: is a message
	if m.Primary != nil || other.Primary != nil {
		updated_Primary, all_Primary := m.Primary.DiffPath(other.Primary)
		if len(updated_Primary) > 0 {
			if all_Primary {
				updated = append(updated, "primary")
			} else {
				for _, u := range updated_Primary {
					updated = append(updated, "primary."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// secondary: is a message
	if m.Secondary != nil || other.Secondary != nil {
		updated_Secondary, all_Secondary := m.Secondary.DiffPath(other.Secondary)
		if len(updated_Secondary) > 0 {
			if all_Secondary {
				updated = append(updated, "secondary")
			} else {
				for _, u := range updated_Secondary {
					updated = append(updated, "secondary."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// taxon: is a message
	if m.Taxon != nil || other.Taxon != nil {
		updated_Taxon, all_Taxon := m.Taxon.DiffPath(other.Taxon)
		if len(updated_Taxon) > 0 {
			if all_Taxon {
				updated = append(updated, "taxon")
			} else {
				for _, u := range updated_Taxon {
					updated = append(updated, "taxon."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// georeference: is a message
	if m.Georeference != nil || other.Georeference != nil {
		updated_Georeference, all_Georeference := m.Georeference.DiffPath(other.Georeference)
		if len(updated_Georeference) > 0 {
			if all_Georeference {
				updated = append(updated, "georeference")
			} else {
				for _, u := range updated_Georeference {
					updated = append(updated, "georeference."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// loans: is a string
	if m.Loans != other.Loans {
		updated = append(updated, "loans")
	} else {
		all = false
	}
	// grants: is a string
	if m.Grants != other.Grants {
		updated = append(updated, "grants")
	} else {
		all = false
	}

	return updated, all
}

func (m *SuggestedStateList) DiffPath(other *SuggestedStateList) (updated []string, all bool) {

	all = true
	// items: is a message
	// TODO: Handle lists

	return updated, all
}
