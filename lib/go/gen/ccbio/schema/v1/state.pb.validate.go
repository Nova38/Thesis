// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: ccbio/schema/v1/state.proto

package schemav1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on LastModified with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LastModified) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LastModified with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LastModifiedMultiError, or
// nil if none found.
func (m *LastModified) ValidateAll() error {
	return m.validate(true)
}

func (m *LastModified) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUserId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LastModifiedValidationError{
					field:  "UserId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LastModifiedValidationError{
					field:  "UserId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LastModifiedValidationError{
				field:  "UserId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserName

	// no validation rules for TxId

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LastModifiedValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LastModifiedValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LastModifiedValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LastModifiedMultiError(errors)
	}

	return nil
}

// LastModifiedMultiError is an error wrapping multiple validation errors
// returned by LastModified.ValidateAll() if the designated constraints aren't met.
type LastModifiedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LastModifiedMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LastModifiedMultiError) AllErrors() []error { return m }

// LastModifiedValidationError is the validation error returned by
// LastModified.Validate if the designated constraints aren't met.
type LastModifiedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LastModifiedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LastModifiedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LastModifiedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LastModifiedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LastModifiedValidationError) ErrorName() string { return "LastModifiedValidationError" }

// Error satisfies the builtin error interface
func (e LastModifiedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLastModified.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LastModifiedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LastModifiedValidationError{}

// Validate checks the field values on Action with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Action) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Action with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ActionMultiError, or nil if none found.
func (m *Action) ValidateAll() error {
	return m.validate(true)
}

func (m *Action) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Level

	if len(errors) > 0 {
		return ActionMultiError(errors)
	}

	return nil
}

// ActionMultiError is an error wrapping multiple validation errors returned by
// Action.ValidateAll() if the designated constraints aren't met.
type ActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionMultiError) AllErrors() []error { return m }

// ActionValidationError is the validation error returned by Action.Validate if
// the designated constraints aren't met.
type ActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionValidationError) ErrorName() string { return "ActionValidationError" }

// Error satisfies the builtin error interface
func (e ActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionValidationError{}

// Validate checks the field values on Collection with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Collection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Collection with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CollectionMultiError, or
// nil if none found.
func (m *Collection) ValidateAll() error {
	return m.validate(true)
}

func (m *Collection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAccessControl()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionValidationError{
					field:  "AccessControl",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionValidationError{
					field:  "AccessControl",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccessControl()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionValidationError{
				field:  "AccessControl",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CollectionMultiError(errors)
	}

	return nil
}

// CollectionMultiError is an error wrapping multiple validation errors
// returned by Collection.ValidateAll() if the designated constraints aren't met.
type CollectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionMultiError) AllErrors() []error { return m }

// CollectionValidationError is the validation error returned by
// Collection.Validate if the designated constraints aren't met.
type CollectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionValidationError) ErrorName() string { return "CollectionValidationError" }

// Error satisfies the builtin error interface
func (e CollectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionValidationError{}

// Validate checks the field values on CollectionList with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CollectionList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionList with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CollectionListMultiError,
// or nil if none found.
func (m *CollectionList) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CollectionListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CollectionListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CollectionListValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CollectionListMultiError(errors)
	}

	return nil
}

// CollectionListMultiError is an error wrapping multiple validation errors
// returned by CollectionList.ValidateAll() if the designated constraints
// aren't met.
type CollectionListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionListMultiError) AllErrors() []error { return m }

// CollectionListValidationError is the validation error returned by
// CollectionList.Validate if the designated constraints aren't met.
type CollectionListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionListValidationError) ErrorName() string { return "CollectionListValidationError" }

// Error satisfies the builtin error interface
func (e CollectionListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionListValidationError{}

// Validate checks the field values on User with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *User) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on User with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UserMultiError, or nil if none found.
func (m *User) ValidateAll() error {
	return m.validate(true)
}

func (m *User) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Name

	// no validation rules for Email

	// no validation rules for Affiliation

	// no validation rules for Memberships

	if len(errors) > 0 {
		return UserMultiError(errors)
	}

	return nil
}

// UserMultiError is an error wrapping multiple validation errors returned by
// User.ValidateAll() if the designated constraints aren't met.
type UserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserMultiError) AllErrors() []error { return m }

// UserValidationError is the validation error returned by User.Validate if the
// designated constraints aren't met.
type UserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserValidationError) ErrorName() string { return "UserValidationError" }

// Error satisfies the builtin error interface
func (e UserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserValidationError{}

// Validate checks the field values on Specimen with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Specimen) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Specimen with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SpecimenMultiError, or nil
// if none found.
func (m *Specimen) ValidateAll() error {
	return m.validate(true)
}

func (m *Specimen) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SpecimenValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SpecimenValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SpecimenValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPrimary()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SpecimenValidationError{
					field:  "Primary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SpecimenValidationError{
					field:  "Primary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrimary()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SpecimenValidationError{
				field:  "Primary",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSecondary()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SpecimenValidationError{
					field:  "Secondary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SpecimenValidationError{
					field:  "Secondary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecondary()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SpecimenValidationError{
				field:  "Secondary",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTaxon()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SpecimenValidationError{
					field:  "Taxon",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SpecimenValidationError{
					field:  "Taxon",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaxon()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SpecimenValidationError{
				field:  "Taxon",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGeoreference()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SpecimenValidationError{
					field:  "Georeference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SpecimenValidationError{
					field:  "Georeference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGeoreference()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SpecimenValidationError{
				field:  "Georeference",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetImages()))
		i := 0
		for key := range m.GetImages() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetImages()[key]
			_ = val

			// no validation rules for Images[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, SpecimenValidationError{
							field:  fmt.Sprintf("Images[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, SpecimenValidationError{
							field:  fmt.Sprintf("Images[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return SpecimenValidationError{
						field:  fmt.Sprintf("Images[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for Loans

	// no validation rules for Grants

	{
		sorted_keys := make([]string, len(m.GetHiddenTxs()))
		i := 0
		for key := range m.GetHiddenTxs() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetHiddenTxs()[key]
			_ = val

			// no validation rules for HiddenTxs[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, SpecimenValidationError{
							field:  fmt.Sprintf("HiddenTxs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, SpecimenValidationError{
							field:  fmt.Sprintf("HiddenTxs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return SpecimenValidationError{
						field:  fmt.Sprintf("HiddenTxs[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetLastModified()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SpecimenValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SpecimenValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastModified()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SpecimenValidationError{
				field:  "LastModified",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SpecimenMultiError(errors)
	}

	return nil
}

// SpecimenMultiError is an error wrapping multiple validation errors returned
// by Specimen.ValidateAll() if the designated constraints aren't met.
type SpecimenMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpecimenMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpecimenMultiError) AllErrors() []error { return m }

// SpecimenValidationError is the validation error returned by
// Specimen.Validate if the designated constraints aren't met.
type SpecimenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpecimenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpecimenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpecimenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpecimenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpecimenValidationError) ErrorName() string { return "SpecimenValidationError" }

// Error satisfies the builtin error interface
func (e SpecimenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecimen.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpecimenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpecimenValidationError{}

// Validate checks the field values on SuggestedUpdate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SuggestedUpdate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SuggestedUpdate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SuggestedUpdateMultiError, or nil if none found.
func (m *SuggestedUpdate) ValidateAll() error {
	return m.validate(true)
}

func (m *SuggestedUpdate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SuggestedUpdateValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SuggestedUpdateValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SuggestedUpdateValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSuggestedBy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SuggestedUpdateValidationError{
					field:  "SuggestedBy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SuggestedUpdateValidationError{
					field:  "SuggestedBy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSuggestedBy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SuggestedUpdateValidationError{
				field:  "SuggestedBy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSuggestedDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SuggestedUpdateValidationError{
					field:  "SuggestedDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SuggestedUpdateValidationError{
					field:  "SuggestedDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSuggestedDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SuggestedUpdateValidationError{
				field:  "SuggestedDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SuggestedReason

	if all {
		switch v := interface{}(m.GetPrimary()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SuggestedUpdateValidationError{
					field:  "Primary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SuggestedUpdateValidationError{
					field:  "Primary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrimary()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SuggestedUpdateValidationError{
				field:  "Primary",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSecondary()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SuggestedUpdateValidationError{
					field:  "Secondary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SuggestedUpdateValidationError{
					field:  "Secondary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecondary()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SuggestedUpdateValidationError{
				field:  "Secondary",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTaxon()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SuggestedUpdateValidationError{
					field:  "Taxon",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SuggestedUpdateValidationError{
					field:  "Taxon",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaxon()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SuggestedUpdateValidationError{
				field:  "Taxon",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGeoreference()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SuggestedUpdateValidationError{
					field:  "Georeference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SuggestedUpdateValidationError{
					field:  "Georeference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGeoreference()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SuggestedUpdateValidationError{
				field:  "Georeference",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Loans

	// no validation rules for Grants

	if len(errors) > 0 {
		return SuggestedUpdateMultiError(errors)
	}

	return nil
}

// SuggestedUpdateMultiError is an error wrapping multiple validation errors
// returned by SuggestedUpdate.ValidateAll() if the designated constraints
// aren't met.
type SuggestedUpdateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SuggestedUpdateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SuggestedUpdateMultiError) AllErrors() []error { return m }

// SuggestedUpdateValidationError is the validation error returned by
// SuggestedUpdate.Validate if the designated constraints aren't met.
type SuggestedUpdateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SuggestedUpdateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SuggestedUpdateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SuggestedUpdateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SuggestedUpdateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SuggestedUpdateValidationError) ErrorName() string { return "SuggestedUpdateValidationError" }

// Error satisfies the builtin error interface
func (e SuggestedUpdateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSuggestedUpdate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SuggestedUpdateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SuggestedUpdateValidationError{}

// Validate checks the field values on SuggestedStateList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SuggestedStateList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SuggestedStateList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SuggestedStateListMultiError, or nil if none found.
func (m *SuggestedStateList) ValidateAll() error {
	return m.validate(true)
}

func (m *SuggestedStateList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SuggestedStateListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SuggestedStateListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SuggestedStateListValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SuggestedStateListMultiError(errors)
	}

	return nil
}

// SuggestedStateListMultiError is an error wrapping multiple validation errors
// returned by SuggestedStateList.ValidateAll() if the designated constraints
// aren't met.
type SuggestedStateListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SuggestedStateListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SuggestedStateListMultiError) AllErrors() []error { return m }

// SuggestedStateListValidationError is the validation error returned by
// SuggestedStateList.Validate if the designated constraints aren't met.
type SuggestedStateListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SuggestedStateListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SuggestedStateListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SuggestedStateListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SuggestedStateListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SuggestedStateListValidationError) ErrorName() string {
	return "SuggestedStateListValidationError"
}

// Error satisfies the builtin error interface
func (e SuggestedStateListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSuggestedStateList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SuggestedStateListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SuggestedStateListValidationError{}

// Validate checks the field values on Collection_Id with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Collection_Id) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Collection_Id with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Collection_IdMultiError, or
// nil if none found.
func (m *Collection_Id) ValidateAll() error {
	return m.validate(true)
}

func (m *Collection_Id) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CollectionId

	if len(errors) > 0 {
		return Collection_IdMultiError(errors)
	}

	return nil
}

// Collection_IdMultiError is an error wrapping multiple validation errors
// returned by Collection_Id.ValidateAll() if the designated constraints
// aren't met.
type Collection_IdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Collection_IdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Collection_IdMultiError) AllErrors() []error { return m }

// Collection_IdValidationError is the validation error returned by
// Collection_Id.Validate if the designated constraints aren't met.
type Collection_IdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Collection_IdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Collection_IdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Collection_IdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Collection_IdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Collection_IdValidationError) ErrorName() string { return "Collection_IdValidationError" }

// Error satisfies the builtin error interface
func (e Collection_IdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollection_Id.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Collection_IdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Collection_IdValidationError{}

// Validate checks the field values on Collection_List with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Collection_List) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Collection_List with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Collection_ListMultiError, or nil if none found.
func (m *Collection_List) ValidateAll() error {
	return m.validate(true)
}

func (m *Collection_List) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Collection_ListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Collection_ListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Collection_ListValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Collection_ListMultiError(errors)
	}

	return nil
}

// Collection_ListMultiError is an error wrapping multiple validation errors
// returned by Collection_List.ValidateAll() if the designated constraints
// aren't met.
type Collection_ListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Collection_ListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Collection_ListMultiError) AllErrors() []error { return m }

// Collection_ListValidationError is the validation error returned by
// Collection_List.Validate if the designated constraints aren't met.
type Collection_ListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Collection_ListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Collection_ListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Collection_ListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Collection_ListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Collection_ListValidationError) ErrorName() string { return "Collection_ListValidationError" }

// Error satisfies the builtin error interface
func (e Collection_ListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollection_List.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Collection_ListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Collection_ListValidationError{}

// Validate checks the field values on Collection_AccessControl with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Collection_AccessControl) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Collection_AccessControl with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Collection_AccessControlMultiError, or nil if none found.
func (m *Collection_AccessControl) ValidateAll() error {
	return m.validate(true)
}

func (m *Collection_AccessControl) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRoles()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Collection_AccessControlValidationError{
					field:  "Roles",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Collection_AccessControlValidationError{
					field:  "Roles",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRoles()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Collection_AccessControlValidationError{
				field:  "Roles",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUsers()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Collection_AccessControlValidationError{
					field:  "Users",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Collection_AccessControlValidationError{
					field:  "Users",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUsers()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Collection_AccessControlValidationError{
				field:  "Users",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSpecimen()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Collection_AccessControlValidationError{
					field:  "Specimen",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Collection_AccessControlValidationError{
					field:  "Specimen",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpecimen()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Collection_AccessControlValidationError{
				field:  "Specimen",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPrimary()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Collection_AccessControlValidationError{
					field:  "Primary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Collection_AccessControlValidationError{
					field:  "Primary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrimary()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Collection_AccessControlValidationError{
				field:  "Primary",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSecondary()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Collection_AccessControlValidationError{
					field:  "Secondary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Collection_AccessControlValidationError{
					field:  "Secondary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecondary()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Collection_AccessControlValidationError{
				field:  "Secondary",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTaxon()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Collection_AccessControlValidationError{
					field:  "Taxon",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Collection_AccessControlValidationError{
					field:  "Taxon",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaxon()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Collection_AccessControlValidationError{
				field:  "Taxon",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGeoreference()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Collection_AccessControlValidationError{
					field:  "Georeference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Collection_AccessControlValidationError{
					field:  "Georeference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGeoreference()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Collection_AccessControlValidationError{
				field:  "Georeference",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetImages()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Collection_AccessControlValidationError{
					field:  "Images",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Collection_AccessControlValidationError{
					field:  "Images",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetImages()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Collection_AccessControlValidationError{
				field:  "Images",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLoans()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Collection_AccessControlValidationError{
					field:  "Loans",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Collection_AccessControlValidationError{
					field:  "Loans",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLoans()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Collection_AccessControlValidationError{
				field:  "Loans",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGrants()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Collection_AccessControlValidationError{
					field:  "Grants",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Collection_AccessControlValidationError{
					field:  "Grants",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGrants()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Collection_AccessControlValidationError{
				field:  "Grants",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Collection_AccessControlMultiError(errors)
	}

	return nil
}

// Collection_AccessControlMultiError is an error wrapping multiple validation
// errors returned by Collection_AccessControl.ValidateAll() if the designated
// constraints aren't met.
type Collection_AccessControlMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Collection_AccessControlMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Collection_AccessControlMultiError) AllErrors() []error { return m }

// Collection_AccessControlValidationError is the validation error returned by
// Collection_AccessControl.Validate if the designated constraints aren't met.
type Collection_AccessControlValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Collection_AccessControlValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Collection_AccessControlValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Collection_AccessControlValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Collection_AccessControlValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Collection_AccessControlValidationError) ErrorName() string {
	return "Collection_AccessControlValidationError"
}

// Error satisfies the builtin error interface
func (e Collection_AccessControlValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollection_AccessControl.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Collection_AccessControlValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Collection_AccessControlValidationError{}

// Validate checks the field values on
// Collection_AccessControl_AccessControlActions with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Collection_AccessControl_AccessControlActions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Collection_AccessControl_AccessControlActions with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// Collection_AccessControl_AccessControlActionsMultiError, or nil if none found.
func (m *Collection_AccessControl_AccessControlActions) ValidateAll() error {
	return m.validate(true)
}

func (m *Collection_AccessControl_AccessControlActions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Collection_AccessControl_AccessControlActionsMultiError(errors)
	}

	return nil
}

// Collection_AccessControl_AccessControlActionsMultiError is an error wrapping
// multiple validation errors returned by
// Collection_AccessControl_AccessControlActions.ValidateAll() if the
// designated constraints aren't met.
type Collection_AccessControl_AccessControlActionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Collection_AccessControl_AccessControlActionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Collection_AccessControl_AccessControlActionsMultiError) AllErrors() []error { return m }

// Collection_AccessControl_AccessControlActionsValidationError is the
// validation error returned by
// Collection_AccessControl_AccessControlActions.Validate if the designated
// constraints aren't met.
type Collection_AccessControl_AccessControlActionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Collection_AccessControl_AccessControlActionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Collection_AccessControl_AccessControlActionsValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Collection_AccessControl_AccessControlActionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Collection_AccessControl_AccessControlActionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Collection_AccessControl_AccessControlActionsValidationError) ErrorName() string {
	return "Collection_AccessControl_AccessControlActionsValidationError"
}

// Error satisfies the builtin error interface
func (e Collection_AccessControl_AccessControlActionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollection_AccessControl_AccessControlActions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Collection_AccessControl_AccessControlActionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Collection_AccessControl_AccessControlActionsValidationError{}

// Validate checks the field values on Collection_AccessControl_SpecimenActions
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Collection_AccessControl_SpecimenActions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Collection_AccessControl_SpecimenActions with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// Collection_AccessControl_SpecimenActionsMultiError, or nil if none found.
func (m *Collection_AccessControl_SpecimenActions) ValidateAll() error {
	return m.validate(true)
}

func (m *Collection_AccessControl_SpecimenActions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Collection_AccessControl_SpecimenActionsMultiError(errors)
	}

	return nil
}

// Collection_AccessControl_SpecimenActionsMultiError is an error wrapping
// multiple validation errors returned by
// Collection_AccessControl_SpecimenActions.ValidateAll() if the designated
// constraints aren't met.
type Collection_AccessControl_SpecimenActionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Collection_AccessControl_SpecimenActionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Collection_AccessControl_SpecimenActionsMultiError) AllErrors() []error { return m }

// Collection_AccessControl_SpecimenActionsValidationError is the validation
// error returned by Collection_AccessControl_SpecimenActions.Validate if the
// designated constraints aren't met.
type Collection_AccessControl_SpecimenActionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Collection_AccessControl_SpecimenActionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Collection_AccessControl_SpecimenActionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Collection_AccessControl_SpecimenActionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Collection_AccessControl_SpecimenActionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Collection_AccessControl_SpecimenActionsValidationError) ErrorName() string {
	return "Collection_AccessControl_SpecimenActionsValidationError"
}

// Error satisfies the builtin error interface
func (e Collection_AccessControl_SpecimenActionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollection_AccessControl_SpecimenActions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Collection_AccessControl_SpecimenActionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Collection_AccessControl_SpecimenActionsValidationError{}

// Validate checks the field values on Collection_AccessControl_SectionActions
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Collection_AccessControl_SectionActions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Collection_AccessControl_SectionActions with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// Collection_AccessControl_SectionActionsMultiError, or nil if none found.
func (m *Collection_AccessControl_SectionActions) ValidateAll() error {
	return m.validate(true)
}

func (m *Collection_AccessControl_SectionActions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Collection_AccessControl_SectionActionsMultiError(errors)
	}

	return nil
}

// Collection_AccessControl_SectionActionsMultiError is an error wrapping
// multiple validation errors returned by
// Collection_AccessControl_SectionActions.ValidateAll() if the designated
// constraints aren't met.
type Collection_AccessControl_SectionActionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Collection_AccessControl_SectionActionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Collection_AccessControl_SectionActionsMultiError) AllErrors() []error { return m }

// Collection_AccessControl_SectionActionsValidationError is the validation
// error returned by Collection_AccessControl_SectionActions.Validate if the
// designated constraints aren't met.
type Collection_AccessControl_SectionActionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Collection_AccessControl_SectionActionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Collection_AccessControl_SectionActionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Collection_AccessControl_SectionActionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Collection_AccessControl_SectionActionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Collection_AccessControl_SectionActionsValidationError) ErrorName() string {
	return "Collection_AccessControl_SectionActionsValidationError"
}

// Error satisfies the builtin error interface
func (e Collection_AccessControl_SectionActionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollection_AccessControl_SectionActions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Collection_AccessControl_SectionActionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Collection_AccessControl_SectionActionsValidationError{}

// Validate checks the field values on User_Id with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *User_Id) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on User_Id with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in User_IdMultiError, or nil if none found.
func (m *User_Id) ValidateAll() error {
	return m.validate(true)
}

func (m *User_Id) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MspId

	// no validation rules for Id

	if len(errors) > 0 {
		return User_IdMultiError(errors)
	}

	return nil
}

// User_IdMultiError is an error wrapping multiple validation errors returned
// by User_Id.ValidateAll() if the designated constraints aren't met.
type User_IdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m User_IdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m User_IdMultiError) AllErrors() []error { return m }

// User_IdValidationError is the validation error returned by User_Id.Validate
// if the designated constraints aren't met.
type User_IdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e User_IdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e User_IdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e User_IdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e User_IdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e User_IdValidationError) ErrorName() string { return "User_IdValidationError" }

// Error satisfies the builtin error interface
func (e User_IdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUser_Id.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = User_IdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = User_IdValidationError{}

// Validate checks the field values on User_List with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *User_List) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on User_List with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in User_ListMultiError, or nil
// if none found.
func (m *User_List) ValidateAll() error {
	return m.validate(true)
}

func (m *User_List) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, User_ListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, User_ListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return User_ListValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return User_ListMultiError(errors)
	}

	return nil
}

// User_ListMultiError is an error wrapping multiple validation errors returned
// by User_List.ValidateAll() if the designated constraints aren't met.
type User_ListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m User_ListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m User_ListMultiError) AllErrors() []error { return m }

// User_ListValidationError is the validation error returned by
// User_List.Validate if the designated constraints aren't met.
type User_ListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e User_ListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e User_ListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e User_ListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e User_ListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e User_ListValidationError) ErrorName() string { return "User_ListValidationError" }

// Error satisfies the builtin error interface
func (e User_ListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUser_List.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = User_ListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = User_ListValidationError{}

// Validate checks the field values on Specimen_Id with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Specimen_Id) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Specimen_Id with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Specimen_IdMultiError, or
// nil if none found.
func (m *Specimen_Id) ValidateAll() error {
	return m.validate(true)
}

func (m *Specimen_Id) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CollectionId

	// no validation rules for Id

	if len(errors) > 0 {
		return Specimen_IdMultiError(errors)
	}

	return nil
}

// Specimen_IdMultiError is an error wrapping multiple validation errors
// returned by Specimen_Id.ValidateAll() if the designated constraints aren't met.
type Specimen_IdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Specimen_IdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Specimen_IdMultiError) AllErrors() []error { return m }

// Specimen_IdValidationError is the validation error returned by
// Specimen_Id.Validate if the designated constraints aren't met.
type Specimen_IdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Specimen_IdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Specimen_IdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Specimen_IdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Specimen_IdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Specimen_IdValidationError) ErrorName() string { return "Specimen_IdValidationError" }

// Error satisfies the builtin error interface
func (e Specimen_IdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecimen_Id.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Specimen_IdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Specimen_IdValidationError{}

// Validate checks the field values on Specimen_List with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Specimen_List) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Specimen_List with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Specimen_ListMultiError, or
// nil if none found.
func (m *Specimen_List) ValidateAll() error {
	return m.validate(true)
}

func (m *Specimen_List) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Specimen_ListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Specimen_ListValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Specimen_ListValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Specimen_ListMultiError(errors)
	}

	return nil
}

// Specimen_ListMultiError is an error wrapping multiple validation errors
// returned by Specimen_List.ValidateAll() if the designated constraints
// aren't met.
type Specimen_ListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Specimen_ListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Specimen_ListMultiError) AllErrors() []error { return m }

// Specimen_ListValidationError is the validation error returned by
// Specimen_List.Validate if the designated constraints aren't met.
type Specimen_ListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Specimen_ListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Specimen_ListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Specimen_ListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Specimen_ListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Specimen_ListValidationError) ErrorName() string { return "Specimen_ListValidationError" }

// Error satisfies the builtin error interface
func (e Specimen_ListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecimen_List.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Specimen_ListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Specimen_ListValidationError{}

// Validate checks the field values on Specimen_History with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Specimen_History) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Specimen_History with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Specimen_HistoryMultiError, or nil if none found.
func (m *Specimen_History) ValidateAll() error {
	return m.validate(true)
}

func (m *Specimen_History) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_HistoryValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_HistoryValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_HistoryValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetEntries() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Specimen_HistoryValidationError{
						field:  fmt.Sprintf("Entries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Specimen_HistoryValidationError{
						field:  fmt.Sprintf("Entries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Specimen_HistoryValidationError{
					field:  fmt.Sprintf("Entries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Specimen_HistoryMultiError(errors)
	}

	return nil
}

// Specimen_HistoryMultiError is an error wrapping multiple validation errors
// returned by Specimen_History.ValidateAll() if the designated constraints
// aren't met.
type Specimen_HistoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Specimen_HistoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Specimen_HistoryMultiError) AllErrors() []error { return m }

// Specimen_HistoryValidationError is the validation error returned by
// Specimen_History.Validate if the designated constraints aren't met.
type Specimen_HistoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Specimen_HistoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Specimen_HistoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Specimen_HistoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Specimen_HistoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Specimen_HistoryValidationError) ErrorName() string { return "Specimen_HistoryValidationError" }

// Error satisfies the builtin error interface
func (e Specimen_HistoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecimen_History.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Specimen_HistoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Specimen_HistoryValidationError{}

// Validate checks the field values on Specimen_Primary with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Specimen_Primary) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Specimen_Primary with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Specimen_PrimaryMultiError, or nil if none found.
func (m *Specimen_Primary) ValidateAll() error {
	return m.validate(true)
}

func (m *Specimen_Primary) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CatalogNumber

	// no validation rules for AccessionNumber

	// no validation rules for FieldNumber

	// no validation rules for TissueNumber

	// no validation rules for Cataloger

	// no validation rules for Collector

	// no validation rules for Determiner

	if all {
		switch v := interface{}(m.GetFieldDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_PrimaryValidationError{
					field:  "FieldDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_PrimaryValidationError{
					field:  "FieldDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFieldDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_PrimaryValidationError{
				field:  "FieldDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCatalogDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_PrimaryValidationError{
					field:  "CatalogDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_PrimaryValidationError{
					field:  "CatalogDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCatalogDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_PrimaryValidationError{
				field:  "CatalogDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeterminedDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_PrimaryValidationError{
					field:  "DeterminedDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_PrimaryValidationError{
					field:  "DeterminedDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeterminedDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_PrimaryValidationError{
				field:  "DeterminedDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DeterminedReason

	if all {
		switch v := interface{}(m.GetLastModified()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_PrimaryValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_PrimaryValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastModified()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_PrimaryValidationError{
				field:  "LastModified",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Specimen_PrimaryMultiError(errors)
	}

	return nil
}

// Specimen_PrimaryMultiError is an error wrapping multiple validation errors
// returned by Specimen_Primary.ValidateAll() if the designated constraints
// aren't met.
type Specimen_PrimaryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Specimen_PrimaryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Specimen_PrimaryMultiError) AllErrors() []error { return m }

// Specimen_PrimaryValidationError is the validation error returned by
// Specimen_Primary.Validate if the designated constraints aren't met.
type Specimen_PrimaryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Specimen_PrimaryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Specimen_PrimaryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Specimen_PrimaryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Specimen_PrimaryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Specimen_PrimaryValidationError) ErrorName() string { return "Specimen_PrimaryValidationError" }

// Error satisfies the builtin error interface
func (e Specimen_PrimaryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecimen_Primary.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Specimen_PrimaryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Specimen_PrimaryValidationError{}

// Validate checks the field values on Specimen_Secondary with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Specimen_Secondary) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Specimen_Secondary with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Specimen_SecondaryMultiError, or nil if none found.
func (m *Specimen_Secondary) ValidateAll() error {
	return m.validate(true)
}

func (m *Specimen_Secondary) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Preparation

	// no validation rules for Condition

	// no validation rules for Notes

	if all {
		switch v := interface{}(m.GetLastModified()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_SecondaryValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_SecondaryValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastModified()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_SecondaryValidationError{
				field:  "LastModified",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Specimen_SecondaryMultiError(errors)
	}

	return nil
}

// Specimen_SecondaryMultiError is an error wrapping multiple validation errors
// returned by Specimen_Secondary.ValidateAll() if the designated constraints
// aren't met.
type Specimen_SecondaryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Specimen_SecondaryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Specimen_SecondaryMultiError) AllErrors() []error { return m }

// Specimen_SecondaryValidationError is the validation error returned by
// Specimen_Secondary.Validate if the designated constraints aren't met.
type Specimen_SecondaryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Specimen_SecondaryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Specimen_SecondaryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Specimen_SecondaryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Specimen_SecondaryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Specimen_SecondaryValidationError) ErrorName() string {
	return "Specimen_SecondaryValidationError"
}

// Error satisfies the builtin error interface
func (e Specimen_SecondaryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecimen_Secondary.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Specimen_SecondaryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Specimen_SecondaryValidationError{}

// Validate checks the field values on Specimen_Taxon with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Specimen_Taxon) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Specimen_Taxon with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Specimen_TaxonMultiError,
// or nil if none found.
func (m *Specimen_Taxon) ValidateAll() error {
	return m.validate(true)
}

func (m *Specimen_Taxon) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kingdom

	// no validation rules for Phylum

	// no validation rules for Class

	// no validation rules for Order

	// no validation rules for Family

	// no validation rules for Genus

	// no validation rules for Species

	// no validation rules for Subspecies

	if all {
		switch v := interface{}(m.GetLastModified()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_TaxonValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_TaxonValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastModified()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_TaxonValidationError{
				field:  "LastModified",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Specimen_TaxonMultiError(errors)
	}

	return nil
}

// Specimen_TaxonMultiError is an error wrapping multiple validation errors
// returned by Specimen_Taxon.ValidateAll() if the designated constraints
// aren't met.
type Specimen_TaxonMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Specimen_TaxonMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Specimen_TaxonMultiError) AllErrors() []error { return m }

// Specimen_TaxonValidationError is the validation error returned by
// Specimen_Taxon.Validate if the designated constraints aren't met.
type Specimen_TaxonValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Specimen_TaxonValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Specimen_TaxonValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Specimen_TaxonValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Specimen_TaxonValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Specimen_TaxonValidationError) ErrorName() string { return "Specimen_TaxonValidationError" }

// Error satisfies the builtin error interface
func (e Specimen_TaxonValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecimen_Taxon.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Specimen_TaxonValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Specimen_TaxonValidationError{}

// Validate checks the field values on Specimen_Georeference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Specimen_Georeference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Specimen_Georeference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Specimen_GeoreferenceMultiError, or nil if none found.
func (m *Specimen_Georeference) ValidateAll() error {
	return m.validate(true)
}

func (m *Specimen_Georeference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Country

	// no validation rules for StateProvince

	// no validation rules for County

	// no validation rules for Locality

	// no validation rules for Latitude

	// no validation rules for Longitude

	// no validation rules for Habitat

	if all {
		switch v := interface{}(m.GetLastModified()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_GeoreferenceValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_GeoreferenceValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastModified()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_GeoreferenceValidationError{
				field:  "LastModified",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Specimen_GeoreferenceMultiError(errors)
	}

	return nil
}

// Specimen_GeoreferenceMultiError is an error wrapping multiple validation
// errors returned by Specimen_Georeference.ValidateAll() if the designated
// constraints aren't met.
type Specimen_GeoreferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Specimen_GeoreferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Specimen_GeoreferenceMultiError) AllErrors() []error { return m }

// Specimen_GeoreferenceValidationError is the validation error returned by
// Specimen_Georeference.Validate if the designated constraints aren't met.
type Specimen_GeoreferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Specimen_GeoreferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Specimen_GeoreferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Specimen_GeoreferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Specimen_GeoreferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Specimen_GeoreferenceValidationError) ErrorName() string {
	return "Specimen_GeoreferenceValidationError"
}

// Error satisfies the builtin error interface
func (e Specimen_GeoreferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecimen_Georeference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Specimen_GeoreferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Specimen_GeoreferenceValidationError{}

// Validate checks the field values on Specimen_Image with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Specimen_Image) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Specimen_Image with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Specimen_ImageMultiError,
// or nil if none found.
func (m *Specimen_Image) ValidateAll() error {
	return m.validate(true)
}

func (m *Specimen_Image) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Url

	// no validation rules for Notes

	// no validation rules for Hash

	if all {
		switch v := interface{}(m.GetLastModified()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_ImageValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_ImageValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastModified()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_ImageValidationError{
				field:  "LastModified",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Specimen_ImageMultiError(errors)
	}

	return nil
}

// Specimen_ImageMultiError is an error wrapping multiple validation errors
// returned by Specimen_Image.ValidateAll() if the designated constraints
// aren't met.
type Specimen_ImageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Specimen_ImageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Specimen_ImageMultiError) AllErrors() []error { return m }

// Specimen_ImageValidationError is the validation error returned by
// Specimen_Image.Validate if the designated constraints aren't met.
type Specimen_ImageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Specimen_ImageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Specimen_ImageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Specimen_ImageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Specimen_ImageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Specimen_ImageValidationError) ErrorName() string { return "Specimen_ImageValidationError" }

// Error satisfies the builtin error interface
func (e Specimen_ImageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecimen_Image.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Specimen_ImageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Specimen_ImageValidationError{}

// Validate checks the field values on Specimen_HiddenTx with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Specimen_HiddenTx) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Specimen_HiddenTx with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Specimen_HiddenTxMultiError, or nil if none found.
func (m *Specimen_HiddenTx) ValidateAll() error {
	return m.validate(true)
}

func (m *Specimen_HiddenTx) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxId

	// no validation rules for Notes

	if all {
		switch v := interface{}(m.GetLastModified()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_HiddenTxValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_HiddenTxValidationError{
					field:  "LastModified",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastModified()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_HiddenTxValidationError{
				field:  "LastModified",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Specimen_HiddenTxMultiError(errors)
	}

	return nil
}

// Specimen_HiddenTxMultiError is an error wrapping multiple validation errors
// returned by Specimen_HiddenTx.ValidateAll() if the designated constraints
// aren't met.
type Specimen_HiddenTxMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Specimen_HiddenTxMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Specimen_HiddenTxMultiError) AllErrors() []error { return m }

// Specimen_HiddenTxValidationError is the validation error returned by
// Specimen_HiddenTx.Validate if the designated constraints aren't met.
type Specimen_HiddenTxValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Specimen_HiddenTxValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Specimen_HiddenTxValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Specimen_HiddenTxValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Specimen_HiddenTxValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Specimen_HiddenTxValidationError) ErrorName() string {
	return "Specimen_HiddenTxValidationError"
}

// Error satisfies the builtin error interface
func (e Specimen_HiddenTxValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecimen_HiddenTx.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Specimen_HiddenTxValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Specimen_HiddenTxValidationError{}

// Validate checks the field values on Specimen_History_Entry with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Specimen_History_Entry) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Specimen_History_Entry with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Specimen_History_EntryMultiError, or nil if none found.
func (m *Specimen_History_Entry) ValidateAll() error {
	return m.validate(true)
}

func (m *Specimen_History_Entry) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxId

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_History_EntryValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_History_EntryValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_History_EntryValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsDeleted

	// no validation rules for IsHidden

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Specimen_History_EntryValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Specimen_History_EntryValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Specimen_History_EntryValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Specimen_History_EntryMultiError(errors)
	}

	return nil
}

// Specimen_History_EntryMultiError is an error wrapping multiple validation
// errors returned by Specimen_History_Entry.ValidateAll() if the designated
// constraints aren't met.
type Specimen_History_EntryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Specimen_History_EntryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Specimen_History_EntryMultiError) AllErrors() []error { return m }

// Specimen_History_EntryValidationError is the validation error returned by
// Specimen_History_Entry.Validate if the designated constraints aren't met.
type Specimen_History_EntryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Specimen_History_EntryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Specimen_History_EntryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Specimen_History_EntryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Specimen_History_EntryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Specimen_History_EntryValidationError) ErrorName() string {
	return "Specimen_History_EntryValidationError"
}

// Error satisfies the builtin error interface
func (e Specimen_History_EntryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecimen_History_Entry.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Specimen_History_EntryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Specimen_History_EntryValidationError{}

// Validate checks the field values on SuggestedUpdate_Id with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SuggestedUpdate_Id) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SuggestedUpdate_Id with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SuggestedUpdate_IdMultiError, or nil if none found.
func (m *SuggestedUpdate_Id) ValidateAll() error {
	return m.validate(true)
}

func (m *SuggestedUpdate_Id) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpecimenId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SuggestedUpdate_IdValidationError{
					field:  "SpecimenId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SuggestedUpdate_IdValidationError{
					field:  "SpecimenId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpecimenId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SuggestedUpdate_IdValidationError{
				field:  "SpecimenId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	if len(errors) > 0 {
		return SuggestedUpdate_IdMultiError(errors)
	}

	return nil
}

// SuggestedUpdate_IdMultiError is an error wrapping multiple validation errors
// returned by SuggestedUpdate_Id.ValidateAll() if the designated constraints
// aren't met.
type SuggestedUpdate_IdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SuggestedUpdate_IdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SuggestedUpdate_IdMultiError) AllErrors() []error { return m }

// SuggestedUpdate_IdValidationError is the validation error returned by
// SuggestedUpdate_Id.Validate if the designated constraints aren't met.
type SuggestedUpdate_IdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SuggestedUpdate_IdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SuggestedUpdate_IdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SuggestedUpdate_IdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SuggestedUpdate_IdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SuggestedUpdate_IdValidationError) ErrorName() string {
	return "SuggestedUpdate_IdValidationError"
}

// Error satisfies the builtin error interface
func (e SuggestedUpdate_IdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSuggestedUpdate_Id.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SuggestedUpdate_IdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SuggestedUpdate_IdValidationError{}
