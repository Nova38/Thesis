// Code generated by protoc-gen-go-hlf. DO NOT EDIT.
// versions:
// - protoc-gen-cckey v0.0.1
// source: rbac/rbac.proto

package rbac

func (m *StateActivity) DiffPath(other *StateActivity) (updated []string, all bool) {

	all = true
	// tx_id: is a string
	if m.TxId != other.TxId {
		updated = append(updated, "tx_id")
	} else {
		all = false
	}
	// note: is a string
	if m.Note != other.Note {
		updated = append(updated, "note")
	} else {
		all = false
	}
	// timestamp: is a message
	// user_id: is a message
	if m.UserId != nil || other.UserId != nil {
		updated_UserId, all_UserId := m.UserId.DiffPath(other.UserId)
		if len(updated_UserId) > 0 {
			if all_UserId {
				updated = append(updated, "user_id")
			} else {
				for _, u := range updated_UserId {
					updated = append(updated, "user_id."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}

	return updated, all
}

func (m *Collection_Id) DiffPath(other *Collection_Id) (updated []string, all bool) {

	all = true
	// collection_id: is a string
	if m.CollectionId != other.CollectionId {
		updated = append(updated, "collection_id")
	} else {
		all = false
	}

	return updated, all
}

func (m *Collection_List) DiffPath(other *Collection_List) (updated []string, all bool) {

	all = true
	// items: is a message
	// TODO: Handle lists

	return updated, all
}

func (m *Collection_ACL) DiffPath(other *Collection_ACL) (updated []string, all bool) {

	all = true
	// role_permissions: is a message
	if m.RolePermissions != nil || other.RolePermissions != nil {
		updated_RolePermissions, all_RolePermissions := m.RolePermissions.DiffPath(other.RolePermissions)
		if len(updated_RolePermissions) > 0 {
			if all_RolePermissions {
				updated = append(updated, "role_permissions")
			} else {
				for _, u := range updated_RolePermissions {
					updated = append(updated, "role_permissions."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// memberships: is a message
	if m.Memberships != nil || other.Memberships != nil {
		updated_Memberships, all_Memberships := m.Memberships.DiffPath(other.Memberships)
		if len(updated_Memberships) > 0 {
			if all_Memberships {
				updated = append(updated, "memberships")
			} else {
				for _, u := range updated_Memberships {
					updated = append(updated, "memberships."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// object: is a message
	if m.Object != nil || other.Object != nil {
		updated_Object, all_Object := m.Object.DiffPath(other.Object)
		if len(updated_Object) > 0 {
			if all_Object {
				updated = append(updated, "object")
			} else {
				for _, u := range updated_Object {
					updated = append(updated, "object."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// object_paths: is a message
	// TODO: Handle maps

	return updated, all
}

func (m *Collection) DiffPath(other *Collection) (updated []string, all bool) {

	all = true
	// id: is a message
	if m.Id != nil || other.Id != nil {
		updated_Id, all_Id := m.Id.DiffPath(other.Id)
		if len(updated_Id) > 0 {
			if all_Id {
				updated = append(updated, "id")
			} else {
				for _, u := range updated_Id {
					updated = append(updated, "id."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// object_namespace: is a string
	if m.ObjectNamespace != other.ObjectNamespace {
		updated = append(updated, "object_namespace")
	} else {
		all = false
	}
	// object_type: is a message
	// roles: is a message
	// TODO: Handle maps
	// role_nums: is a int32
	// TODO: Handle lists
	// acl: is a message
	// TODO: Handle maps

	return updated, all
}

func (m *Operations_Action) DiffPath(other *Operations_Action) (updated []string, all bool) {

	all = true
	// type: is a enum
	if m.Type != other.Type {
		updated = append(updated, "type")
	} else {
		all = false
	}
	// paths: is a message

	return updated, all
}

func (m *Operations_Membership) DiffPath(other *Operations_Membership) (updated []string, all bool) {

	all = true
	// view: is a bool
	if m.View != other.View {
		updated = append(updated, "view")
	} else {
		all = false
	}
	// edit: is a bool
	if m.Edit != other.Edit {
		updated = append(updated, "edit")
	} else {
		all = false
	}

	return updated, all
}

func (m *Operations_Object) DiffPath(other *Operations_Object) (updated []string, all bool) {

	all = true
	// view: is a bool
	if m.View != other.View {
		updated = append(updated, "view")
	} else {
		all = false
	}
	// create: is a bool
	if m.Create != other.Create {
		updated = append(updated, "create")
	} else {
		all = false
	}
	// delete: is a bool
	if m.Delete != other.Delete {
		updated = append(updated, "delete")
	} else {
		all = false
	}
	// hidden_txs: is a bool
	if m.HiddenTxs != other.HiddenTxs {
		updated = append(updated, "hidden_txs")
	} else {
		all = false
	}

	return updated, all
}

func (m *Operations_ObjectField) DiffPath(other *Operations_ObjectField) (updated []string, all bool) {

	all = true
	// view: is a bool
	if m.View != other.View {
		updated = append(updated, "view")
	} else {
		all = false
	}
	// edit: is a bool
	if m.Edit != other.Edit {
		updated = append(updated, "edit")
	} else {
		all = false
	}
	// suggest_edit: is a bool
	if m.SuggestEdit != other.SuggestEdit {
		updated = append(updated, "suggest_edit")
	} else {
		all = false
	}
	// suggest_approve: is a bool
	if m.SuggestApprove != other.SuggestApprove {
		updated = append(updated, "suggest_approve")
	} else {
		all = false
	}
	// suggest_reject: is a bool
	if m.SuggestReject != other.SuggestReject {
		updated = append(updated, "suggest_reject")
	} else {
		all = false
	}

	return updated, all
}

func (m *Operations_PathRolePermission) DiffPath(other *Operations_PathRolePermission) (updated []string, all bool) {

	all = true
	// path: is a string
	if m.Path != other.Path {
		updated = append(updated, "path")
	} else {
		all = false
	}
	// sub_paths: is a message
	// TODO: Handle maps
	// acl: is a message
	// TODO: Handle maps

	return updated, all
}

func (m *Operations) DiffPath(other *Operations) (updated []string, all bool) {

	all = true

	return updated, all
}

func (m *User_Id) DiffPath(other *User_Id) (updated []string, all bool) {

	all = true
	// msp_id: is a string
	if m.MspId != other.MspId {
		updated = append(updated, "msp_id")
	} else {
		all = false
	}
	// id: is a string
	if m.Id != other.Id {
		updated = append(updated, "id")
	} else {
		all = false
	}

	return updated, all
}

func (m *User_List) DiffPath(other *User_List) (updated []string, all bool) {

	all = true
	// items: is a message
	// TODO: Handle lists

	return updated, all
}

func (m *User) DiffPath(other *User) (updated []string, all bool) {

	all = true
	// id: is a message
	if m.Id != nil || other.Id != nil {
		updated_Id, all_Id := m.Id.DiffPath(other.Id)
		if len(updated_Id) > 0 {
			if all_Id {
				updated = append(updated, "id")
			} else {
				for _, u := range updated_Id {
					updated = append(updated, "id."+u)
				}
			}
		} else {
			all = false
		}
	} else {
		all = false
	}
	// name: is a string
	if m.Name != other.Name {
		updated = append(updated, "name")
	} else {
		all = false
	}
	// roles: is a message
	// TODO: Handle maps
	// metadata: is a message

	return updated, all
}
