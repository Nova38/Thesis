// @generated by protoc-gen-es v1.3.1 with parameter "target=ts"
// @generated from file auth/v1/auth.proto (package auth, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { FieldMask, Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from message auth.Identifier
 */
export class Identifier extends Message<Identifier> {
  /**
   * @generated from oneof auth.Identifier.id
   */
  id: {
    /**
     * @generated from field: auth.Identifier.Attribute attribute = 1;
     */
    value: Identifier_Attribute;
    case: "attribute";
  } | {
    /**
     * @generated from field: auth.Identifier.Role role = 2;
     */
    value: Identifier_Role;
    case: "role";
  } | {
    /**
     * @generated from field: auth.Identifier.Identity identity = 3;
     */
    value: Identifier_Identity;
    case: "identity";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Identifier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.Identifier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "attribute", kind: "message", T: Identifier_Attribute, oneof: "id" },
    { no: 2, name: "role", kind: "message", T: Identifier_Role, oneof: "id" },
    { no: 3, name: "identity", kind: "message", T: Identifier_Identity, oneof: "id" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Identifier {
    return new Identifier().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Identifier {
    return new Identifier().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Identifier {
    return new Identifier().fromJsonString(jsonString, options);
  }

  static equals(a: Identifier | PlainMessage<Identifier> | undefined, b: Identifier | PlainMessage<Identifier> | undefined): boolean {
    return proto3.util.equals(Identifier, a, b);
  }
}

/**
 * @generated from message auth.Identifier.Attribute
 */
export class Identifier_Attribute extends Message<Identifier_Attribute> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string msp_id = 2;
   */
  mspId = "";

  /**
   * @generated from field: string value = 3;
   */
  value = "";

  constructor(data?: PartialMessage<Identifier_Attribute>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.Identifier.Attribute";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "msp_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Identifier_Attribute {
    return new Identifier_Attribute().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Identifier_Attribute {
    return new Identifier_Attribute().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Identifier_Attribute {
    return new Identifier_Attribute().fromJsonString(jsonString, options);
  }

  static equals(a: Identifier_Attribute | PlainMessage<Identifier_Attribute> | undefined, b: Identifier_Attribute | PlainMessage<Identifier_Attribute> | undefined): boolean {
    return proto3.util.equals(Identifier_Attribute, a, b);
  }
}

/**
 * @generated from message auth.Identifier.Role
 */
export class Identifier_Role extends Message<Identifier_Role> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<Identifier_Role>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.Identifier.Role";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Identifier_Role {
    return new Identifier_Role().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Identifier_Role {
    return new Identifier_Role().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Identifier_Role {
    return new Identifier_Role().fromJsonString(jsonString, options);
  }

  static equals(a: Identifier_Role | PlainMessage<Identifier_Role> | undefined, b: Identifier_Role | PlainMessage<Identifier_Role> | undefined): boolean {
    return proto3.util.equals(Identifier_Role, a, b);
  }
}

/**
 * @generated from message auth.Identifier.Identity
 */
export class Identifier_Identity extends Message<Identifier_Identity> {
  /**
   * @generated from field: string msp_id = 1;
   */
  mspId = "";

  /**
   * @generated from field: string id = 2;
   */
  id = "";

  constructor(data?: PartialMessage<Identifier_Identity>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.Identifier.Identity";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "msp_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Identifier_Identity {
    return new Identifier_Identity().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Identifier_Identity {
    return new Identifier_Identity().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Identifier_Identity {
    return new Identifier_Identity().fromJsonString(jsonString, options);
  }

  static equals(a: Identifier_Identity | PlainMessage<Identifier_Identity> | undefined, b: Identifier_Identity | PlainMessage<Identifier_Identity> | undefined): boolean {
    return proto3.util.equals(Identifier_Identity, a, b);
  }
}

/**
 * @generated from message auth.Operation
 */
export class Operation extends Message<Operation> {
  /**
   * @generated from field: auth.Operation.Domain domain = 1;
   */
  domain = Operation_Domain.UNSPECIFIED;

  /**
   * @generated from field: auth.Operation.Action action = 2;
   */
  action = Operation_Action.UNSPECIFIED;

  /**
   * @generated from field: google.protobuf.FieldMask paths = 3;
   */
  paths?: FieldMask;

  constructor(data?: PartialMessage<Operation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.Operation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "domain", kind: "enum", T: proto3.getEnumType(Operation_Domain) },
    { no: 2, name: "action", kind: "enum", T: proto3.getEnumType(Operation_Action) },
    { no: 3, name: "paths", kind: "message", T: FieldMask },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Operation {
    return new Operation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Operation {
    return new Operation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Operation {
    return new Operation().fromJsonString(jsonString, options);
  }

  static equals(a: Operation | PlainMessage<Operation> | undefined, b: Operation | PlainMessage<Operation> | undefined): boolean {
    return proto3.util.equals(Operation, a, b);
  }
}

/**
 * @generated from enum auth.Operation.Domain
 */
export enum Operation_Domain {
  /**
   * @generated from enum value: DOMAIN_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Meta create
   *
   * @generated from enum value: DOMAIN_COLLECTION = 1;
   */
  COLLECTION = 1,

  /**
   * @generated from enum value: DOMAIN_COLLECTION_MEMBERSHIP = 2;
   */
  COLLECTION_MEMBERSHIP = 2,

  /**
   * @generated from enum value: DOMAIN_COLLECTION_PERMISSION = 3;
   */
  COLLECTION_PERMISSION = 3,

  /**
   * @generated from enum value: DOMAIN_COLLECTION_ROLES = 4;
   */
  COLLECTION_ROLES = 4,

  /**
   * @generated from enum value: DOMAIN_USER = 5;
   */
  USER = 5,

  /**
   * @generated from enum value: DOMAIN_OBJECT = 6;
   */
  OBJECT = 6,

  /**
   * @generated from enum value: DOMAIN_OBJECT_FIELD = 7;
   */
  OBJECT_FIELD = 7,

  /**
   * Test
   *
   * @generated from enum value: DOMAIN_TEST = 100;
   */
  TEST = 100,
}
// Retrieve enum metadata with: proto3.getEnumType(Operation_Domain)
proto3.util.setEnumType(Operation_Domain, "auth.Operation.Domain", [
  { no: 0, name: "DOMAIN_UNSPECIFIED" },
  { no: 1, name: "DOMAIN_COLLECTION" },
  { no: 2, name: "DOMAIN_COLLECTION_MEMBERSHIP" },
  { no: 3, name: "DOMAIN_COLLECTION_PERMISSION" },
  { no: 4, name: "DOMAIN_COLLECTION_ROLES" },
  { no: 5, name: "DOMAIN_USER" },
  { no: 6, name: "DOMAIN_OBJECT" },
  { no: 7, name: "DOMAIN_OBJECT_FIELD" },
  { no: 100, name: "DOMAIN_TEST" },
]);

/**
 * @generated from enum auth.Operation.Action
 */
export enum Operation_Action {
  /**
   * Default
   *
   * @generated from enum value: ACTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * View
   *
   * @generated from enum value: ACTION_VIEW = 1;
   */
  VIEW = 1,

  /**
   * Create
   *
   * @generated from enum value: ACTION_CREATE = 2;
   */
  CREATE = 2,

  /**
   * Delete
   *
   * @generated from enum value: ACTION_DELETE = 3;
   */
  DELETE = 3,

  /**
   * Edit/Update
   *
   * @generated from enum value: ACTION_EDIT = 4;
   */
  EDIT = 4,

  /**
   * View the suggested update to the object
   *
   * @generated from enum value: ACTION_VIEW_SUGGEST = 5;
   */
  VIEW_SUGGEST = 5,

  /**
   * Suggest an update to the object
   *
   * @generated from enum value: ACTION_SUGGEST_EDIT = 6;
   */
  SUGGEST_EDIT = 6,

  /**
   * Approve the suggested update
   *
   * @generated from enum value: ACTION_SUGGEST_APPROVE = 7;
   */
  SUGGEST_APPROVE = 7,

  /**
   * Reject the suggested update
   *
   * @generated from enum value: ACTION_SUGGEST_REJECT = 8;
   */
  SUGGEST_REJECT = 8,

  /**
   * View the history of the object
   *
   * @generated from enum value: ACTION_VIEW_HISTORY = 9;
   */
  VIEW_HISTORY = 9,

  /**
   * view, hide, unhide
   *
   * @generated from enum value: ACTION_HIDDEN_TX = 10;
   */
  HIDDEN_TX = 10,

  /**
   * Test
   *
   * @generated from enum value: ACTION_TEST = 100;
   */
  TEST = 100,
}
// Retrieve enum metadata with: proto3.getEnumType(Operation_Action)
proto3.util.setEnumType(Operation_Action, "auth.Operation.Action", [
  { no: 0, name: "ACTION_UNSPECIFIED" },
  { no: 1, name: "ACTION_VIEW" },
  { no: 2, name: "ACTION_CREATE" },
  { no: 3, name: "ACTION_DELETE" },
  { no: 4, name: "ACTION_EDIT" },
  { no: 5, name: "ACTION_VIEW_SUGGEST" },
  { no: 6, name: "ACTION_SUGGEST_EDIT" },
  { no: 7, name: "ACTION_SUGGEST_APPROVE" },
  { no: 8, name: "ACTION_SUGGEST_REJECT" },
  { no: 9, name: "ACTION_VIEW_HISTORY" },
  { no: 10, name: "ACTION_HIDDEN_TX" },
  { no: 100, name: "ACTION_TEST" },
]);

/**
 * @generated from message auth.ACL
 */
export class ACL extends Message<ACL> {
  /**
   * The string is the stringified Identifier
   *
   * @generated from field: map<string, auth.ACL.Entry> entries = 1;
   */
  entries: { [key: string]: ACL_Entry } = {};

  /**
   * The default is the base permissions for all users
   *
   * @generated from field: auth.ACL.Entry default = 2;
   */
  default?: ACL_Entry;

  /**
   * The public is the base permissions unregistered users. Manly for viewing
   *
   * @generated from field: auth.ACL.Entry public = 3;
   */
  public?: ACL_Entry;

  constructor(data?: PartialMessage<ACL>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.ACL";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entries", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: ACL_Entry} },
    { no: 2, name: "default", kind: "message", T: ACL_Entry },
    { no: 3, name: "public", kind: "message", T: ACL_Entry },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ACL {
    return new ACL().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ACL {
    return new ACL().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ACL {
    return new ACL().fromJsonString(jsonString, options);
  }

  static equals(a: ACL | PlainMessage<ACL> | undefined, b: ACL | PlainMessage<ACL> | undefined): boolean {
    return proto3.util.equals(ACL, a, b);
  }
}

/**
 * Types of Policies for the ACL
 *
 * @generated from message auth.ACL.Policy
 */
export class ACL_Policy extends Message<ACL_Policy> {
  constructor(data?: PartialMessage<ACL_Policy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.ACL.Policy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ACL_Policy {
    return new ACL_Policy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ACL_Policy {
    return new ACL_Policy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ACL_Policy {
    return new ACL_Policy().fromJsonString(jsonString, options);
  }

  static equals(a: ACL_Policy | PlainMessage<ACL_Policy> | undefined, b: ACL_Policy | PlainMessage<ACL_Policy> | undefined): boolean {
    return proto3.util.equals(ACL_Policy, a, b);
  }
}

/**
 * Policy for altering the membership of a role or perms of a role
 *
 * @generated from message auth.ACL.Policy.Permission
 */
export class ACL_Policy_Permission extends Message<ACL_Policy_Permission> {
  /**
   * @generated from field: bool view = 1;
   */
  view = false;

  /**
   * @generated from field: bool create = 2;
   */
  create = false;

  /**
   * @generated from field: bool edit = 3;
   */
  edit = false;

  /**
   * @generated from field: bool delete = 4;
   */
  delete = false;

  constructor(data?: PartialMessage<ACL_Policy_Permission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.ACL.Policy.Permission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "view", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "create", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "edit", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ACL_Policy_Permission {
    return new ACL_Policy_Permission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ACL_Policy_Permission {
    return new ACL_Policy_Permission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ACL_Policy_Permission {
    return new ACL_Policy_Permission().fromJsonString(jsonString, options);
  }

  static equals(a: ACL_Policy_Permission | PlainMessage<ACL_Policy_Permission> | undefined, b: ACL_Policy_Permission | PlainMessage<ACL_Policy_Permission> | undefined): boolean {
    return proto3.util.equals(ACL_Policy_Permission, a, b);
  }
}

/**
 * Policy for altering the object
 *
 * @generated from message auth.ACL.Policy.Object
 */
export class ACL_Policy_Object extends Message<ACL_Policy_Object> {
  /**
   * @generated from field: bool view = 1;
   */
  view = false;

  /**
   * @generated from field: bool create = 2;
   */
  create = false;

  /**
   * @generated from field: bool delete = 3;
   */
  delete = false;

  /**
   * @generated from field: bool view_history = 4;
   */
  viewHistory = false;

  /**
   * @generated from field: bool hidden_tx = 5;
   */
  hiddenTx = false;

  constructor(data?: PartialMessage<ACL_Policy_Object>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.ACL.Policy.Object";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "view", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "create", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "view_history", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "hidden_tx", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ACL_Policy_Object {
    return new ACL_Policy_Object().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ACL_Policy_Object {
    return new ACL_Policy_Object().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ACL_Policy_Object {
    return new ACL_Policy_Object().fromJsonString(jsonString, options);
  }

  static equals(a: ACL_Policy_Object | PlainMessage<ACL_Policy_Object> | undefined, b: ACL_Policy_Object | PlainMessage<ACL_Policy_Object> | undefined): boolean {
    return proto3.util.equals(ACL_Policy_Object, a, b);
  }
}

/**
 * Policy for altering the object
 *
 * @generated from message auth.ACL.Policy.ObjectField
 */
export class ACL_Policy_ObjectField extends Message<ACL_Policy_ObjectField> {
  /**
   * @generated from field: bool view = 1;
   */
  view = false;

  /**
   * @generated from field: bool edit = 2;
   */
  edit = false;

  /**
   * @generated from field: bool suggest_edit = 3;
   */
  suggestEdit = false;

  /**
   * @generated from field: bool suggest_approve = 4;
   */
  suggestApprove = false;

  /**
   * @generated from field: bool suggest_reject = 5;
   */
  suggestReject = false;

  constructor(data?: PartialMessage<ACL_Policy_ObjectField>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.ACL.Policy.ObjectField";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "view", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "edit", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "suggest_edit", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "suggest_approve", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "suggest_reject", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ACL_Policy_ObjectField {
    return new ACL_Policy_ObjectField().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ACL_Policy_ObjectField {
    return new ACL_Policy_ObjectField().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ACL_Policy_ObjectField {
    return new ACL_Policy_ObjectField().fromJsonString(jsonString, options);
  }

  static equals(a: ACL_Policy_ObjectField | PlainMessage<ACL_Policy_ObjectField> | undefined, b: ACL_Policy_ObjectField | PlainMessage<ACL_Policy_ObjectField> | undefined): boolean {
    return proto3.util.equals(ACL_Policy_ObjectField, a, b);
  }
}

/**
 * This message is the tree node for operations on the state object
 *
 * @generated from message auth.ACL.PathPermission
 */
export class ACL_PathPermission extends Message<ACL_PathPermission> {
  /**
   * The path is a sub path of a field mask
   *
   * @generated from field: string path = 1;
   */
  path = "";

  /**
   * @generated from field: bool allow_sub_paths = 2;
   */
  allowSubPaths = false;

  /**
   * The key is a valid sub path in the type of state object
   *
   * @generated from field: map<string, auth.ACL.PathPermission> sub_paths = 3;
   */
  subPaths: { [key: string]: ACL_PathPermission } = {};

  /**
   * If the policy is not set than use a parent policy unless nested policy is set
   *
   * @generated from field: auth.ACL.Policy.ObjectField policy = 4;
   */
  policy?: ACL_Policy_ObjectField;

  constructor(data?: PartialMessage<ACL_PathPermission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.ACL.PathPermission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "allow_sub_paths", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "sub_paths", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: ACL_PathPermission} },
    { no: 4, name: "policy", kind: "message", T: ACL_Policy_ObjectField },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ACL_PathPermission {
    return new ACL_PathPermission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ACL_PathPermission {
    return new ACL_PathPermission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ACL_PathPermission {
    return new ACL_PathPermission().fromJsonString(jsonString, options);
  }

  static equals(a: ACL_PathPermission | PlainMessage<ACL_PathPermission> | undefined, b: ACL_PathPermission | PlainMessage<ACL_PathPermission> | undefined): boolean {
    return proto3.util.equals(ACL_PathPermission, a, b);
  }
}

/**
 * @generated from message auth.ACL.Entry
 */
export class ACL_Entry extends Message<ACL_Entry> {
  /**
   * @generated from field: auth.ACL.Policy.Permission memberships = 1;
   */
  memberships?: ACL_Policy_Permission;

  /**
   * @generated from field: auth.ACL.Policy.Permission role_permissions = 2;
   */
  rolePermissions?: ACL_Policy_Permission;

  /**
   * @generated from field: auth.ACL.Policy.Permission role_defs = 3;
   */
  roleDefs?: ACL_Policy_Permission;

  /**
   * @generated from field: auth.ACL.Policy.Object object = 4;
   */
  object?: ACL_Policy_Object;

  /**
   * @generated from field: auth.ACL.PathPermission object_paths = 5;
   */
  objectPaths?: ACL_PathPermission;

  /**
   * @generated from field: google.protobuf.FieldMask view_mask = 6;
   */
  viewMask?: FieldMask;

  constructor(data?: PartialMessage<ACL_Entry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.ACL.Entry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "memberships", kind: "message", T: ACL_Policy_Permission },
    { no: 2, name: "role_permissions", kind: "message", T: ACL_Policy_Permission },
    { no: 3, name: "role_defs", kind: "message", T: ACL_Policy_Permission },
    { no: 4, name: "object", kind: "message", T: ACL_Policy_Object },
    { no: 5, name: "object_paths", kind: "message", T: ACL_PathPermission },
    { no: 6, name: "view_mask", kind: "message", T: FieldMask },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ACL_Entry {
    return new ACL_Entry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ACL_Entry {
    return new ACL_Entry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ACL_Entry {
    return new ACL_Entry().fromJsonString(jsonString, options);
  }

  static equals(a: ACL_Entry | PlainMessage<ACL_Entry> | undefined, b: ACL_Entry | PlainMessage<ACL_Entry> | undefined): boolean {
    return proto3.util.equals(ACL_Entry, a, b);
  }
}

/**
 * @generated from message auth.Collection
 */
export class Collection extends Message<Collection> {
  /**
   * The key for the ledger
   *
   * @generated from field: auth.Collection.Id id = 1;
   */
  id?: Collection_Id;

  /**
   * @generated from field: auth.Collection.Settings settings = 2;
   */
  settings?: Collection_Settings;

  /**
   * The full type of object that this collection will store
   *
   * @generated from field: string object_type = 3;
   */
  objectType = "";

  /**
   * The namespace of the object that this collection will store
   *
   * @generated from field: string object_namespace = 4;
   */
  objectNamespace = "";

  /**
   * @generated from field: auth.ACL acl = 5;
   */
  acl?: ACL;

  /**
   * The key is the stringified Identifier
   * The value is the IdentifierEntry, which contains the Identifier and the parents
   * The parents are the attributes that this attribute is derived from
   *
   * @generated from field: map<string, auth.Collection.IdentifierEntry> identifiers = 6;
   */
  identifiers: { [key: string]: Collection_IdentifierEntry } = {};

  constructor(data?: PartialMessage<Collection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.Collection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: Collection_Id },
    { no: 2, name: "settings", kind: "message", T: Collection_Settings },
    { no: 3, name: "object_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "object_namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "acl", kind: "message", T: ACL },
    { no: 6, name: "identifiers", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Collection_IdentifierEntry} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Collection {
    return new Collection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Collection {
    return new Collection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Collection {
    return new Collection().fromJsonString(jsonString, options);
  }

  static equals(a: Collection | PlainMessage<Collection> | undefined, b: Collection | PlainMessage<Collection> | undefined): boolean {
    return proto3.util.equals(Collection, a, b);
  }
}

/**
 * @generated from enum auth.Collection.AuthType
 */
export enum Collection_AuthType {
  /**
   * @generated from enum value: AUTH_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Role based access control:
   * 1. Valid Roles are defined in the roles list
   * 2. Roles are assigned to users in the memberships map
   * 3. Permissions are stored in the Collections ACL with the role id as the key
   *
   * @generated from enum value: AUTH_TYPE_RBAC = 1;
   */
  RBAC = 1,

  /**
   * Attribute based access control:
   * 1. Valid Attribute definitions are defined in the attributes list
   * 2. Attributes are stored in the users x509 certificate
   * 3. Permissions are stored in the Collections ACL with the user id as the key
   *
   * @generated from enum value: AUTH_TYPE_ABAC = 2;
   */
  ABAC = 2,

  /**
   * Identity based access control:
   * 1. Valid Identities are users registered in the smart contract
   * 2. Permissions are stored in the Collections ACL with the user id as the key
   *
   * @generated from enum value: AUTH_TYPE_IDENTITY = 3;
   */
  IDENTITY = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(Collection_AuthType)
proto3.util.setEnumType(Collection_AuthType, "auth.Collection.AuthType", [
  { no: 0, name: "AUTH_TYPE_UNSPECIFIED" },
  { no: 1, name: "AUTH_TYPE_RBAC" },
  { no: 2, name: "AUTH_TYPE_ABAC" },
  { no: 3, name: "AUTH_TYPE_IDENTITY" },
]);

/**
 * @generated from message auth.Collection.IdentifierEntry
 */
export class Collection_IdentifierEntry extends Message<Collection_IdentifierEntry> {
  /**
   * @generated from field: auth.Identifier identifier = 1;
   */
  identifier?: Identifier;

  /**
   * The parent attribute that this attribute is derived from
   * If this is set, then it means that it should look in the permissions of
   * the parent attribute to if the user doesn't have a defined permission
   * for this attribute. Only if a non-root permission is not defined for the
   * the attribute will it look back to the parent attribute for a permissions.
   * This allows for a hierarchy of attributes to be defined
   *
   * @generated from field: repeated string parents = 2;
   */
  parents: string[] = [];

  constructor(data?: PartialMessage<Collection_IdentifierEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.Collection.IdentifierEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "identifier", kind: "message", T: Identifier },
    { no: 2, name: "parents", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Collection_IdentifierEntry {
    return new Collection_IdentifierEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Collection_IdentifierEntry {
    return new Collection_IdentifierEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Collection_IdentifierEntry {
    return new Collection_IdentifierEntry().fromJsonString(jsonString, options);
  }

  static equals(a: Collection_IdentifierEntry | PlainMessage<Collection_IdentifierEntry> | undefined, b: Collection_IdentifierEntry | PlainMessage<Collection_IdentifierEntry> | undefined): boolean {
    return proto3.util.equals(Collection_IdentifierEntry, a, b);
  }
}

/**
 * @generated from message auth.Collection.Settings
 */
export class Collection_Settings extends Message<Collection_Settings> {
  /**
   * The type of authentication to use for this collection
   *
   * @generated from field: auth.Collection.AuthType auth_type = 1;
   */
  authType = Collection_AuthType.UNSPECIFIED;

  /**
   * If true, then the ACL will be used to restrict the view of the object
   * to only those users who have been granted access to that level of the object
   * This means that for listing objects, a filter will have to be applied
   * to each object. For list all objects, this will be a very expensive operation
   * as it will require walking multiple collections paths
   *
   * @generated from field: bool view_restrictions_enabled = 2;
   */
  viewRestrictionsEnabled = false;

  /**
   * @generated from field: bool acl_inheritance_enabled = 3;
   */
  aclInheritanceEnabled = false;

  constructor(data?: PartialMessage<Collection_Settings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.Collection.Settings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "auth_type", kind: "enum", T: proto3.getEnumType(Collection_AuthType) },
    { no: 2, name: "view_restrictions_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "acl_inheritance_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Collection_Settings {
    return new Collection_Settings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Collection_Settings {
    return new Collection_Settings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Collection_Settings {
    return new Collection_Settings().fromJsonString(jsonString, options);
  }

  static equals(a: Collection_Settings | PlainMessage<Collection_Settings> | undefined, b: Collection_Settings | PlainMessage<Collection_Settings> | undefined): boolean {
    return proto3.util.equals(Collection_Settings, a, b);
  }
}

/**
 * @generated from message auth.Collection.Id
 */
export class Collection_Id extends Message<Collection_Id> {
  /**
   * @generated from field: string collection_id = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<Collection_Id>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.Collection.Id";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Collection_Id {
    return new Collection_Id().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Collection_Id {
    return new Collection_Id().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Collection_Id {
    return new Collection_Id().fromJsonString(jsonString, options);
  }

  static equals(a: Collection_Id | PlainMessage<Collection_Id> | undefined, b: Collection_Id | PlainMessage<Collection_Id> | undefined): boolean {
    return proto3.util.equals(Collection_Id, a, b);
  }
}

/**
 * @generated from message auth.User
 */
export class User extends Message<User> {
  /**
   * @generated from field: auth.User.Id id = 1;
   */
  id?: User_Id;

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * Memberships stores the roles that the user has in each collection
   * Key is the collection id
   * Value is the role id
   *
   * @generated from field: map<string, string> memberships = 3;
   */
  memberships: { [key: string]: string } = {};

  constructor(data?: PartialMessage<User>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.User";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: User_Id },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "memberships", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): User {
    return new User().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): User {
    return new User().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): User {
    return new User().fromJsonString(jsonString, options);
  }

  static equals(a: User | PlainMessage<User> | undefined, b: User | PlainMessage<User> | undefined): boolean {
    return proto3.util.equals(User, a, b);
  }
}

/**
 * The key for the ledger
 *
 * @generated from message auth.User.Id
 */
export class User_Id extends Message<User_Id> {
  /**
   * @generated from field: string msp_id = 1;
   */
  mspId = "";

  /**
   * @generated from field: string id = 2;
   */
  id = "";

  constructor(data?: PartialMessage<User_Id>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.User.Id";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "msp_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): User_Id {
    return new User_Id().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): User_Id {
    return new User_Id().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): User_Id {
    return new User_Id().fromJsonString(jsonString, options);
  }

  static equals(a: User_Id | PlainMessage<User_Id> | undefined, b: User_Id | PlainMessage<User_Id> | undefined): boolean {
    return proto3.util.equals(User_Id, a, b);
  }
}

