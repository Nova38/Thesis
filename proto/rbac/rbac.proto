syntax = "proto3";

package rbac;

import "buf/validate/validate.proto";
import "google/api/annotations.proto";
import "google/protobuf/descriptor.proto";
import "google/protobuf/type.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/timestamp.proto";


import "key/key.proto";

// Collections look up is a tree structure


message StateActivity{
    string tx_id = 1;
    string note = 2;
    google.protobuf.Timestamp timestamp = 3;
    User.Id user_id = 4;
}





/*
* TODO:
* 
*/


message Collection {
  option (key.key_schema).namespace = "collection";
  option (key.key_schema).key_paths = {
    paths: ["id.collection_id"]
  };

  message Id {
    string collection_id = 1 [(buf.validate.field).string.email = true];
  }

  message List {
    repeated Collection items = 1;
  }
  
    message ACL {
        // Declared Permissions for the permissions of all roles in the collection
        //   - The value is the permissions for the role
        Operations.Membership role_permissions = 5 ;
    
        // acl_memberships are the permissions for assigning roles to users
        // Keys must be valid role ids defined in the roles map
    
        // Declared Permissions for the memberships of all roles in the Collection
        //   - The key is the role id
        //   - The value is the permissions for the role 
        Operations.Membership memberships = 6;
    
        // acl_object are the permissions for the object
        // Keys must be valid role ids defined in the roles map
        Operations.Object object = 7;
        
        //  ObjectField Permissions
        // Key must be a valid field path in the object descriptor
        map<string, Operations.PathRolePermission> object_paths = 8;
    } 

    
  Id id = 1;

  // The namespace of the object
  string object_namespace = 2;

  // protobuf message descriptor
  // google.protobuf.Type object_type = 3 [(buf.validate.field).required = true];
  google.protobuf.Type object_type = 3 [(buf.validate.field).required = true];


  // Declared Roles for the collection
  //   - The key is the role id
  //   - The value is the role name
  map<int32, string> roles = 4 ;

  repeated int32 role_nums = 9;

  // Declared Permissions for the permissions of all roles in the collection
  map<int32, ACL> acl = 5;

  // --------------------------------------------------------------------------
  // Validations
  // --------------------------------------------------------------------------

  // Role ids in the ACL must be defined in the roles map
  // ----------------------------------------------------

    option (buf.validate.message).cel = {
        id: "ACL Keys"
        message: "ACL[Role]: The keys must be valid role ids defined in the roles map"
        expression: "this.acl.all(role, has(this.roles.role))"
    };


  // Object paths 
  // ----------------------------------------------------

}

message Operations {
    enum Domain {
        DOMAIN_UNSPECIFIED = 0;
        DOMAIN_COLLECTION = 1;
        DOMAIN_OBJECT = 2;
        DOMAIN_OBJECT_FIELD = 3;
    }
    
    message Action{
        enum Type {
            TYPE_UNSPECIFIED = 0;
            TYPE_VIEW = 1;
            TYPE_EDIT = 2;
            TYPE_SUGGEST_EDIT = 3;
            TYPE_SUGGEST_APPROVE = 4;
            TYPE_SUGGEST_REJECT = 5;
            TYPE_CREATE = 6;
            TYPE_DELETE = 7;
            TYPE_HIDDEN_TX = 8;
            TYPE_INIT = 9;
        }
        
        Type type = 1;
        google.protobuf.FieldMask paths = 2;
    }
    
    

    message Membership {
        bool view = 1;
        bool edit = 2;
    }
    message Object {
        bool view = 1;
        bool create = 2;
        bool delete = 3;
        bool hidden_txs = 4;
    }
    message ObjectField {
        bool view = 1;
        bool edit = 2;
        bool suggest_edit = 3;
        bool suggest_approve = 4;
        bool suggest_reject = 5;
    }

    // This message is the tree node for operations on the state object
    message PathRolePermission {
        // The path is a sub path of a field mask
        string path = 1 [(buf.validate.field).string.min_len = 1];

        // The key is a valid sub path in the collection object descriptor
        map<string, PathRolePermission> sub_paths = 2;

        // The Key must be a valid role id defined in the roles map
        map<int32, Operations.ObjectField> acl = 3 [(buf.validate.field).required = true];
    }


    Domain domain = 1;
    Action action = 2;
}

// Users are a special type of object
message User {
  option (key.key_schema).namespace = "users";
  option (key.key_schema).key_paths = {
    paths: [
      "id.msp_id",
      "id.id"
    ]
  };

  // The key for the ledger
  message Id {
    string msp_id = 1 [(buf.validate.field).string.min_len = 1];
    string id = 2 [(buf.validate.field).string.min_len = 1];
  }
  message List {
    repeated User items = 1;
  }

  Id id = 1 [(buf.validate.field).required = true];

  string name = 2 [(buf.validate.field).string.min_len = 1];

  // Key is the collectionID
  map<string, int32> roles = 3;
  google.protobuf.Struct metadata = 4;
}
