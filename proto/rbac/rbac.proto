syntax = "proto3";

package rbac;

import "buf/validate/validate.proto";
import "google/protobuf/descriptor.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/any.proto";


import "hlf/key.proto";

// Define method options
extend google.protobuf.MethodOptions {
  ACL.Operation operation = 57777;
}




// The ACL will be defined in a map per role
message ACL {
  enum Domain {
    DOMAIN_UNSPECIFIED = 0;

    // Meta create
    DOMAIN_COLLECTION = 1;
        DOMAIN_COLLECTION_MEMBERSHIP = 2;
      DOMAIN_COLLECTION_PERMISSION = 3;
      DOMAIN_COLLECTION_ROLES = 4;

    DOMAIN_USER = 5;

    DOMAIN_OBJECT = 6;
    DOMAIN_OBJECT_FIELD = 7;

  }
  enum Action {
    ACTION_UNSPECIFIED = 0;   // Default
    ACTION_VIEW = 1;          // View
    ACTION_CREATE = 2;        // Create
    ACTION_DELETE = 3;        // Delete
    ACTION_EDIT = 4;          // Edit/Update

    ACTION_VIEW_SUGGEST = 5;    // View the suggested update to the object
    ACTION_SUGGEST_EDIT = 6;    // Suggest an update to the object
    ACTION_SUGGEST_APPROVE = 7; // Approve the suggested update
    ACTION_SUGGEST_REJECT = 8;  // Reject the suggested update

    ACTION_VIEW_HISTORY = 9;    // View the history of the object

    ACTION_HIDDEN_TX = 10;      // view, hide, unhide
  }

  message Operation {
    Domain domain = 1;
    Action action = 2;
    google.protobuf.FieldMask paths = 3;


    option (buf.validate.message).cel = {
        id: "domain.missing.action.missing"
        message: "Domain and action must not be set to unspecified"
        expression: "this.domain != 0 || this.action != 0"
    };

    option (buf.validate.message).cel = {
      id: "domain.Collection.AllowedActions"
      message: "Collection domain allows only create"
      expression: "this.domain != 1 && this.action in(2,3)"
    };

    option (buf.validate.message).cel = {
      id: "domain.COLLECTION_MEMBERSHIP.AllowedActions"
      message: "Collection membership domain  not "
      expression: "this.domain != 2 "
    };

    option (buf.validate.message).cel = {
      id: "domain.COLLECTION_PERMISSION.AllowedActions"
      message: "Collection Permissions domain allows only view,edit,delete"
      expression: "this.domain != 3 && this.action in(1,3,4)"
    };

    option (buf.validate.message).cel = {
      id: "domain.DOMAIN_COLLECTION_ROLES.AllowedActions"
      message: "Collection Roles domain allows only view,create,delete,edit"
      expression: "this.domain != 4 && this.action in(1,2,3,4)"
    };

    option (buf.validate.message).cel = {
      id: "domain.User.AllowedActions"
      message: "User domain allows only view,create,delete,edit"
      expression: "this.domain != 5 && this.action in(1,2,3,4)"
    };

    option (buf.validate.message).cel = {
      id: "domain.Object.AllowedActions"
      message: "Collection Object domain allows only view,create,delete,history,hidden"
      expression: "this.domain != 6 && this.action in(1,2,3,9,10)"
    };

    option (buf.validate.message).cel = {
      id: "domain.Object_Field.AllowedActions"
      message: "Collection Object Field only allows view,edit,suggested_edit,suggested_approve,suggested_reject"
      expression: "this.domain != 7 && this.action in(1,4,5,6,7,8)"
    };


  }
  // Types of Policies for the ACL
  message Policy {

    // Policy for altering the membership of a role or perms of a role
    message Roles {
      bool view = 1;
      bool create = 2;
      bool edit = 3;
      bool delete = 4;
    }

    // Policy for altering the object
    message Object {
      bool view = 1;
      bool create = 2;
      bool delete = 3;
      bool view_history = 4;
      bool hidden_tx = 5;
    }

    // Policy for altering the object
    message ObjectField {
      bool view = 1;
      bool edit = 2;
      bool suggest_edit = 3;
      bool suggest_approve = 4;
      bool suggest_reject = 5;
    }

    oneof policy {
      Roles roles = 1;
      Roles membership = 2;
      Object object = 3;
      ObjectField object_field = 4;
    }
  }

  // This message is the tree node for operations on the state object
  message PathRolePermission {
    // The path is a sub path of a field mask
    string path = 1 [(buf.validate.field).string.min_len = 1];

    bool allow_sub_paths = 2;
    // The key is a valid sub path in the type of state object
    map<string, PathRolePermission> sub_paths = 3;

    // The Key must be a valid role id defined in the roles map
    Policy.ObjectField policy = 4 [(buf.validate.field).required = true];


    option (buf.validate.message).cel = {
        id: "SubPathsAllowed"
        message: "Sub Paths are not allowed"
        expression: "!this.allow_sub_paths && this.sub_paths.size() > 0"
    };

  }


  // The permissions for modifications to valid roles in the collection
  // # Policy
  //   - Maps to the domain: DOMAIN_COLLECTION_ROLES
  Policy.Roles role_defs = 1 [(buf.validate.field).required = true];

  // The permissions for modifications the permissions of a role
  // # Policy
  //   - Maps to the domain: DOMAIN_COLLECTION_PERMISSION
  Policy.Roles role_permissions  = 2 [(buf.validate.field).required = true];

  // The permissions for modifications user memberships in the collection
  // # Policy
  //   - Maps to the domain: DOMAIN_USER
  Policy.Roles memberships = 3 [(buf.validate.field).required = true];

  // The permissions for modifications to the object
  // # Policy
  //   - Maps to the domain: DOMAIN_OBJECT
  Policy.Object object = 4 [(buf.validate.field).required = true];

  // The permissions for modifications to the object's fields
  // # Policy
  //   - Maps to the domain: DOMAIN_OBJECT_FIELD
  PathRolePermission object_paths = 5 [(buf.validate.field).required = true];
}



message Collection {
  option (hlf.key_schema).namespace = "collection";
  option (hlf.key_schema).key_paths = {
    paths: ["id.collection_id"]
  };

  message Id {
    string collection_id = 1 [(buf.validate.field).string.min_len = 1];
  }

  // The key for the ledger
  Id id = 1;

  // The namespace of the object
  string object_namespace = 2;

  // protobuf message descriptor
  // google.protobuf.Type object_type = 3 [(buf.validate.field).required = true];

  // The full name of the object type
  // must be a valid protobuf message type
  string object_type = 3 [(buf.validate.field).required = true];

  // Declared Roles for the collection
  //   - The key is the role id
  //   - The value is the role name
  map<int32, string> roles = 4 ;

  repeated int32 role_nums = 9;

  // Declared Permissions for the permissions of all roles in the collection
  map<int32, ACL> acl = 5;

  // --------------------------------------------------------------------------
  // Validations
  // --------------------------------------------------------------------------

  // Role ids in the ACL must be defined in the roles map
  // ----------------------------------------------------

    option (buf.validate.message).cel = {
        id: "ACL Keys"
        message: "ACL[Role]: The keys must be valid role ids defined in the roles map"
        expression: "this.acl.all(role, has(this.roles.role))"
    };


  // Object paths
  // ----------------------------------------------------

}

// Users are a special type of object
// buf:lint:ignore MESSAGE_NO_DELETE
message User {
  option (hlf.key_schema).namespace = "users";
  option (hlf.key_schema).key_paths = {
    paths: [
      "id.msp_id",
      "id.id"
    ]
  };

  // The key for the ledger
  message Id {
    string msp_id = 1 [(buf.validate.field).string.min_len = 1];
    string id = 2 [(buf.validate.field).string.min_len = 1];
  }

  message Role {
    Collection.Id collection_id = 1;
    int32 role_id = 2;
    User.Id granted_by = 3;
  }

  // The key for the ledger
  Id id = 1 [(buf.validate.field).required = true];

  string name = 2 [(buf.validate.field).string.min_len = 1];

  // Key is the collectionID
  map<string, Role> roles = 3;
  google.protobuf.Struct metadata = 4;
}





// Utils


message StateActivity{
  string tx_id = 1 [(buf.validate.field).string.min_len = 1];
  string note = 2;
  google.protobuf.Timestamp timestamp = 3 [(buf.validate.field).required = true];
  User.Id user_id = 4;
}

message History {
  message Entry {
    string tx_id = 1;
    google.protobuf.Timestamp timestamp = 2;
    bool is_deleted = 3;
    bool is_hidden = 4;
    google.protobuf.Any state = 5;
  }

  repeated Entry entries = 1;
}


enum Error {
  ERROR_UNSPECIFIED = 0;
  ERROR_REQUEST_INVALID = 1;
  ERROR_RUNTIME = 2;
  ERROR_RUNTIME_BAD_OPS = 3;

  /* Collection Errors */

  // The collection id is invalid
  ERROR_COLLECTION_INVALID_ID = 11;
  // The collection is not registered
  ERROR_COLLECTION_UNREGISTERED = 12;
  // The collection is already registered
  ERROR_COLLECTION_ALREADY_REGISTERED = 13;
  // The Collection is invalid
  ERROR_COLLECTION_INVALID = 14;
  // The object type name is invalid
  ERROR_COLLECTION_INVALID_OBJECT_TYPE = 15;
  // The role id is invalid
  ERROR_COLLECTION_INVALID_ROLE_ID = 16;


  // User Errors

  // The user does not have permission to perform the operation
  ERROR_USER_INVALID_ID = 20;
  // The user is not registered
  ERROR_USER_UNREGISTERED = 21;
  // The user is already registered
  ERROR_USER_ALREADY_REGISTERED = 22;
  // The user is invalid
  ERROR_USER_INVALID = 23;
  // The user does not have a role in the collection
  ERROR_USER_NO_ROLE = 24;
  // The user has a deleted role in the collection
  ERROR_USER_DELETED_ROLE = 25;
  // The user does not have permission to perform the operation
  ERROR_USER_PERMISSION_DENIED = 26;



  // The object id is invalid
  ERROR_OBJECT_INVALID_ID = 31;
  // The object is not registered
  ERROR_OBJECT_UNREGISTERED = 32;
  // The object is already registered
  ERROR_OBJECT_ALREADY_REGISTERED = 33;
  // The object is invalid
  ERROR_OBJECT_INVALID = 34;

  //
  ERROR_INVALID_OBJECT_FIELD_PATH = 35;
  ERROR_INVALID_OBJECT_FIELD_VALUE = 36;


  //


}
