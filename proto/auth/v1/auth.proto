syntax = "proto3";

package auth;

import "buf/validate/validate.proto";
import "google/protobuf/any.proto";
import "google/protobuf/descriptor.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/timestamp.proto";

// import "auth/options/options.proto";

// ═════════════════════════════════════════════
// Message Options
// ═════════════════════════════════════════════

enum TransactionType {
  TRANSACTION_TYPE_UNSPECIFIED = 0;
  TRANSACTION_TYPE_INVOKE      = 1;
  TRANSACTION_TYPE_QUERY       = 2;
}
enum ObjectKind {
  OBJECT_KIND_UNSPECIFIED = 0;
  OBJECT_KIND_GLOBAL_OBJECT      = 1;
  // Object's key := {COLLECTION_ID}{TYPE}[...key_paths]
  OBJECT_KIND_PRIMARY_OBJECT = 2;
  // Object's key := {COLLECTION_ID}{TYPE}<PrimaryKey>{...key_paths}
  OBJECT_KIND_SUB_OBJECT = 3;
  OBJECT_KIND_REFERENCE  = 4;
}

message KeySchema {
  // The object type of the key
  string object_type                       = 1;
  // The kind of object that the key is for
  ObjectKind object_kind               = 2;
  // The paths that make up the key
  google.protobuf.FieldMask keys           = 3;
}

// Define method options
extend google.protobuf.MethodOptions {
  Operation operation              = 57775;
  TransactionType transaction_type = 50556;
}
extend google.protobuf.MessageOptions {
  KeySchema key_schema = 54599;
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// Misc message options
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// Can be used as the history entry
message StateActivity {
  // The transaction id that caused the change
  string tx_id   = 1 [(buf.validate.field).string.min_len = 1];
  // The msp of the user that caused the change
  string msp_id  = 2 [(buf.validate.field).string.min_len = 1];
  // The id of the user that caused the change
  string user_id = 3 [(buf.validate.field).string.min_len = 1];
  // The timestamp of the change
  google.protobuf.Timestamp timestamp = 4
      [(buf.validate.field).required = true];
  // A note about the change
  string note = 5;
}

message HistoryEntry {
  // The transaction id that caused the change
  string tx_id   = 1 [(buf.validate.field).string.min_len = 1];
  // Whether the object was deleted
  bool is_delete = 2;
  // Whether the transaction was hidden
  bool is_hidden = 3;
  // The timestamp of the change
  google.protobuf.Timestamp timestamp = 4
      [(buf.validate.field).required = true];
  // A note about the change
  string note               = 5;
  // The value of the object
  google.protobuf.Any value = 6;
}

message History {
  repeated HistoryEntry entries = 1;
  HiddenTxList hidden_txs       = 2;
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// ═════════════════════════════════════════════
// Access Control
// ═════════════════════════════════════════════

message Operation {
  Action action                     = 1;
  string collection_id              = 2;
  string object_type                = 3;
  string secondary_object_type      = 4;
  google.protobuf.FieldMask paths   = 5;
}

// Action - The action to be performed during the operation
//
// # Action Groups
//   - UNSPECIFIED: null or not set
//   - REGISTER:    Used to register a new user or collection (always allowed)
//   - COLLECTION:  Used to manage collections permissions
//   - MEMBERSHIP:  Used to manage membership of a collection
//   - OBJECT:      Used to manage objects in a collection
enum Action {
  ACTION_UNSPECIFIED         = 0;
  ACTION_UTILITY             = 1;


  // View the contents of an object
  ACTION_VIEW = 10;
  // Create a new object
  //  - key must not already exist
  ACTION_CREATE = 11;
  // Update an existing object
  //   - key must already exist
  ACTION_UPDATE = 12;
  // Delete an existing object, key must already exist
  ACTION_DELETE = 13;

  // Suggest a change to an object, key must already exist
  ACTION_SUGGEST_VIEW = 14;

  // Suggest a change to an object, key must already exist
  ACTION_SUGGEST_CREATE  = 15;
  // Delete a suggestion, key must already exist
  ACTION_SUGGEST_DELETE  = 16;
  // Approve a suggestion and apply it to the object, key must already exist
  ACTION_SUGGEST_APPROVE = 17;

  ACTION_VIEW_HISTORY    = 18;
  ACTION_VIEW_HIDDEN_TXS = 19;
  ACTION_HIDE_TX         = 20;


  ACTION_REFERENCE_CREATE = 21;
  ACTION_REFERENCE_DELETE = 22;
  ACTION_REFERENCE_VIEW   = 23;

}



// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// ═════════════════════════════════════════════
// Access Control
// ═════════════════════════════════════════════


// This message is the tree node for operations on the state object
message PathPolicy {
  // The path is a sub path of a field mask
  string path      = 1 [(buf.validate.field).string.min_len = 1];
  string full_path = 2 [(buf.validate.field).string.min_len = 1];

  bool allow_sub_paths = 3;
  // The key is a valid sub path in the type of state object
  map<string, PathPolicy> sub_paths = 4;

  // If the policy is not set than use a parent policy unless nested policy is set
  repeated Action actions = 5;


  option (buf.validate.message).cel = {
    id: "SubPathsAllowed"
    message: "Sub Paths are not allowed"
    expression: "!this.allow_sub_paths && this.sub_paths.size() > 0"
  };
  // option (buf.validate.message).cel = {
  //   id: "pathAndFullPath"
  //   message: "Path must be a sub path of full path"
  //   expression: "!this.allow_sub_paths && this.sub_paths.size() > 0"
  // };
}

// message ObjectPolicy {
//   string object_type           = 1 [(buf.validate.field).required = true];
//   PathPolicy path_policies = 2;
// }

// Access Control Entry for use in Hash Tree
message ACEntry {
  // ObjectPolicy root                 = 1 [(buf.validate.field).required = true];

  // key is the object type
  map<string, PathPolicy> children = 1;
}





// ──────────────────────────────────────────────────


// Auth Types
// ──────────────────────────────────────────────────

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// ═════════════════════════════════════════════════════════════════════════════
// Collection Object Wrapper Types
// ═════════════════════════════════════════════════════════════════════════════

message Object {
  ObjectKey key             = 1;
  google.protobuf.Any value = 2 [(buf.validate.field).any = {
    not_in: [
      "type.googleapis.com/auth.Suggestion"
      "type.googleapis.com/auth.HiddenTxList"
      "type.googleapis.com/auth.ACEntry"
      "type.googleapis.com/auth.PathPolicy"

      ]
  }];
}

message FullObject {
  ObjectKey key              = 1;
  google.protobuf.Any value  = 2;
  History history            = 3;
  repeated Suggestion suggestions = 4;
  repeated Reference references   = 5;
}

// Lists
// ─────────────────────────────────────────────────────────────────────────────────


/* Keys
─────────────────────────────────────────────────────────────────────────────────────
Object Keys
 When converted to its string form it will be:
  - Key := {OBJECT_TYPE}{COLLECTION_ID}{...OBJECT_ID}

Reference Keys
  Used to store references to objects for case like a user having a role
  When converted to its string form it will be:
  {Ref}{REFERENCE_TYPE}{COLLECTION_ID}[{OBJECT1_TYPE}{...OBJECT1_ID}][{OBJECT2_TYPE}{...OBJECT2_ID}]


SubKeys
 When converted to its string form it will be:
 {SUB_OBJECT_TYPE}{COLLECTION_ID}{OBJECT_TYPE}{...OBJECT_ID}{SUB_OBJECT_ID}
     Examples
       - Suggestion := {auth.Suggestion}  {COLLECTION_ID}{OBJECT_TYPE}{...OBJECT_ID}{SUGGESTION_ID}
       - HiddenTxList := {auth.HiddenTxList}{COLLECTION_ID}{OBJECT_TYPE} {...OBJECT_ID}
*/
message ObjectKey {
  string collection_id            = 1;
  string object_type              = 2;
  repeated string object_id_parts = 3;
}

// Reference Keys
// {auth.Reference}{REFERENCE_TYPE}{COLLECTION_ID}[{OBJECT1_TYPE}{...OBJECT1_ID}][{OBJECT2_TYPE}{...OBJECT2_ID}]
message Reference {
  option (key_schema).object_kind = OBJECT_KIND_REFERENCE;

  string collection_id  = 1;
  string reference_type = 2;
  ObjectKey key_1       = 3;
  ObjectKey key_2       = 4;
}





// ═════════════════════════════════════════════════════════════════════════════════
// Global Objects
// ═════════════════════════════════════════════════════════════════════════════════

// Collection
// ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
// Note that the types of objects are stored in the default ACEntry
//
// key := {COLLECTION}{COLLECTION_ID}
message Collection {
  option (key_schema).object_kind = OBJECT_KIND_GLOBAL_OBJECT;
  option (key_schema).keys          = {
    paths: [ "collection_id" ]
  };

  // The key for the ledger
  string collection_id = 1 [(buf.validate.field).string.min_len = 1];
  string name                  = 2 [(buf.validate.field).string.min_len = 1];
  string description           = 3 [(buf.validate.field).string.min_len = 1];
  repeated string object_types = 4;
  ACEntry default              = 5 [(buf.validate.field).required = true];
}

// User
// ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
//
// key := {USER}{USER_ID.msp_id}{USER_ID.id}
//
message User {
  option (key_schema).object_kind = OBJECT_KIND_GLOBAL_OBJECT;
  option (key_schema).keys          = {
    paths: [ "msp_id", "user_id" ]
  };

  string collection_id = 1 [(buf.validate.field).string.const = "global"];
  string msp_id        = 2 [(buf.validate.field).string.min_len = 1];
  string user_id       = 3 [(buf.validate.field).string.min_len = 1];
  string name          = 4;
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ═════════════════════════════════════════════════════════════════════════════════
// Sub Object Types
// ═════════════════════════════════════════════════════════════════════════════════




// Key should be
// {auth.Suggestion}{COLLECTION_ID}{OBJECT_TYPE}{...OBJECT_ID}{SUGGESTION_ID}
message Suggestion {
  option (key_schema).object_kind = OBJECT_KIND_SUB_OBJECT;
  option (key_schema).keys = {paths: [ "suggestion_id" ]};

  ObjectKey primary_key           = 1;
  string suggestion_id            = 2;
  google.protobuf.FieldMask paths = 5;
  google.protobuf.Any value       = 6;
}



message HiddenTx {
  string tx_id   = 1 [(buf.validate.field).string.min_len = 1];
  string msp_id  = 2;
  string user_id = 3;
  google.protobuf.Timestamp timestamp = 4
      [(buf.validate.field).required = true];
  string note = 5;
}

// Key should be {COLLECTION_ID}{auth.HiddenTxList}{OBJECT_TYPE}{...OBJECT_ID}
message HiddenTxList {
  option (key_schema).object_kind = OBJECT_KIND_SUB_OBJECT;

  ObjectKey primary_key = 1;  // The key that is used to store the object
  repeated HiddenTx txs = 4;  // The list of hidden txs by tx_id
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ═════════════════════════════════════════════════════════════════════════════════
// Collection Objects
// ═════════════════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────────────────────────────────────
// Access Control Objects
// ─────────────────────────────────────────────────────────────────────────────────

message Role {
  option (auth.key_schema).object_kind = OBJECT_KIND_PRIMARY_OBJECT;
  option (auth.key_schema).keys          = {
    paths: [ "role_id" ]
  };

  string collection_id            = 1 [(buf.validate.field).string.min_len = 1];
  string role_id                  = 2 [(buf.validate.field).string.min_len = 1];
  auth.ACEntry ac                 = 4 [(buf.validate.field).required = true];
  string description              = 5 [(buf.validate.field).string.min_len = 1];
  repeated string parent_role_ids = 6;
}

// An attribute is used to define permissions via the value of the attribute in the
// users certificate for a given msp
message Attribute {
  option (auth.key_schema).object_kind = OBJECT_KIND_PRIMARY_OBJECT;
  option (auth.key_schema).keys          = {
    paths: [ "msp_id", "oid", "role_id" ]
  };
  string collection_id = 1 [(buf.validate.field).string.min_len = 1];

  // The msp of the organization that this attribute applies to
  string msp_id = 2 [(buf.validate.field).string.min_len = 1];
  // The oid of the attribute
  string oid = 3 [(buf.validate.field).string.min_len = 1];
  // The value of the attribute required to be satisfied by the user to have the
  // role
  string value = 4 [(buf.validate.field).string.min_len = 1];
  // The Permission that the user will have if they have the attribute
  auth.ACEntry ac = 5 [(buf.validate.field).required = true];


}

// Membership is used to store permissions for a user in a collection
message Membership {
  option (auth.key_schema).object_kind = OBJECT_KIND_PRIMARY_OBJECT;
  option (auth.key_schema).keys          = {
    paths: [ "msp_id", "user_id" ]
  };

  // The collection that the user is a member of
  string collection_id = 1 [(buf.validate.field).string.const = "global"];
  // The msp of the organization that the user's certificate is from
  string msp_id        = 2 [(buf.validate.field).string.min_len = 1];
  // The id of the user from the certificate
  string user_id       = 3 [(buf.validate.field).required = true];
  // The Permissions that the user will have
  auth.ACEntry ac      = 4 [(buf.validate.field).required = true];
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

enum TxError {
  UNSPECIFIED        = 0;
  REQUEST_INVALID    = 1;
  RUNTIME            = 2;
  RUNTIME_BAD_OPS    = 3;
  // The provided key is not in the world state
  KEY_NOT_FOUND      = 4;
  // The provided key is already in the world state
  KEY_ALREADY_EXISTS = 5;

  /* Collection Errors */


  // The collection id is invalid
  COLLECTION_INVALID_ID          = 11;
  // The collection is not registered and thus cannot be accessed
  COLLECTION_UNREGISTERED        = 12;
  // The collection is already registered and thus cannot be registered again
  COLLECTION_ALREADY_REGISTERED  = 13;
  // The collection is invalid (e.g. the collection does not have a default ACEntry)
  COLLECTION_INVALID             = 14;

  // The object type in the collection is invalid
  COLLECTION_INVALID_OBJECT_TYPE = 15;
  // The role id in the collection is invalid
  COLLECTION_INVALID_ROLE_ID     = 16;

  /* User Errors */

  // The user does not have permission to perform the operation
  USER_INVALID_ID            = 20;
  // The certificate is not registered as a user and thus cannot be used
  USER_UNREGISTERED          = 21;
  // The certificate is already registered as a user and thus cannot be registered again
  USER_ALREADY_REGISTERED    = 22;
  // The user is invalid
  USER_INVALID               = 23;
  // The user does not have a role
  USER_NO_ROLE               = 24;
  // USER_DELETED_ROLE          = 25;
  // The user does not have permission to perform the operation
  USER_PERMISSION_DENIED     = 26;
  // The Object's key is invalid
  OBJECT_INVALID_ID          = 31;
  // The Object is not registered and thus cannot be accessed
  OBJECT_UNREGISTERED        = 32;
  // The Object is already registered and thus cannot be registered again
  OBJECT_ALREADY_REGISTERED  = 33;
  // The Object is invalid
  OBJECT_INVALID             = 34;

  // The object field path is invalid for the object type
  INVALID_OBJECT_FIELD_PATH  = 35;
  // The value at the object field path is invalid for the object type
  INVALID_OBJECT_FIELD_VALUE = 36;
}
