syntax = "proto3";

package auth;

import "buf/validate/validate.proto";
import "google/protobuf/descriptor.proto";
import "google/protobuf/field_mask.proto";

import "hlf/key.proto";


// Define method options
extend google.protobuf.MethodOptions {
  Operation operation = 57775;
}



message Identifier {
  message Attribute {
    string name   = 1 [(buf.validate.field).string.min_len = 1];
    string msp_id = 2 [(buf.validate.field).string.min_len = 1];
    string value  = 3 [(buf.validate.field).string.min_len = 1];
  }

  message Role {
    option (hlf.key_schema).namespace = "roles";
    option (hlf.key_schema).key_paths = {
      paths: ["id"]
    };
    string id   = 1 [(buf.validate.field).string.min_len = 1];
  }


  message Identity {
    option (hlf.key_schema).namespace = "identities";
    option (hlf.key_schema).key_paths = {
      paths: ["msp_id", "id"]
    };
    string msp_id = 1 [(buf.validate.field).string.min_len = 1];
    string id   = 2 [(buf.validate.field).string.min_len = 1];
  }




  oneof id {
    Attribute attribute = 1;
    Role role = 2;
    Identity identity = 3;
  }


}




message Operation {
  enum Domain {
    DOMAIN_UNSPECIFIED = 0;

    // Meta create
    DOMAIN_COLLECTION = 1;
    DOMAIN_COLLECTION_MEMBERSHIP = 2;
    DOMAIN_COLLECTION_PERMISSION = 3;
    DOMAIN_COLLECTION_ROLES = 4;
    DOMAIN_USER = 5;
    DOMAIN_OBJECT = 6;
    DOMAIN_OBJECT_FIELD = 7;
    DOMAIN_TEST = 100; // Test
  }
  enum Action {
    ACTION_UNSPECIFIED = 0; // Default
    ACTION_VIEW = 1; // View
    ACTION_CREATE = 2; // Create
    ACTION_DELETE = 3; // Delete
    ACTION_EDIT = 4; // Edit/Update

    ACTION_VIEW_SUGGEST = 5; // View the suggested update to the object
    ACTION_SUGGEST_EDIT = 6; // Suggest an update to the object
    ACTION_SUGGEST_APPROVE = 7; // Approve the suggested update
    ACTION_SUGGEST_REJECT = 8; // Reject the suggested update

    ACTION_VIEW_HISTORY = 9; // View the history of the object

    ACTION_HIDDEN_TX = 10; // view, hide, unhide

    ACTION_TEST = 100; // Test
  }

  Domain domain = 1;
  Action action = 2;
  google.protobuf.FieldMask paths = 3;

  option (buf.validate.message).cel = {
    id: "domain.missing.action.missing"
    message: "Domain and action must not be set to unspecified"
    expression: "this.domain != 0 || this.action != 0"
  };

  option (buf.validate.message).cel = {
    id: "domain.Collection.AllowedActions"
    message: "Collection domain allows only create"
    expression: "this.domain != 1 && this.action in(2,3)"
  };

  option (buf.validate.message).cel = {
    id: "domain.COLLECTION_MEMBERSHIP.AllowedActions"
    message: "Collection membership domain  not "
    expression: "this.domain != 2 "
  };

  option (buf.validate.message).cel = {
    id: "domain.COLLECTION_PERMISSION.AllowedActions"
    message: "Collection Permissions domain allows only view,edit,delete"
    expression: "this.domain != 3 && this.action in(1,3,4)"
  };

  option (buf.validate.message).cel = {
    id: "domain.DOMAIN_COLLECTION_ROLES.AllowedActions"
    message: "Collection Roles domain allows only view,create,delete,edit"
    expression: "this.domain != 4 && this.action in(1,2,3,4)"
  };

  option (buf.validate.message).cel = {
    id: "domain.User.AllowedActions"
    message: "User domain allows only view,create,delete,edit"
    expression: "this.domain != 5 && this.action in(1,2,3,4)"
  };

  option (buf.validate.message).cel = {
    id: "domain.Object.AllowedActions"
    message: "Collection Object domain allows only view,create,delete,history,hidden"
    expression: "this.domain != 6 && this.action in(1,2,3,9,10)"
  };

  option (buf.validate.message).cel = {
    id: "domain.Object_Field.AllowedActions"
    message: "Collection Object Field only allows view,edit,suggested_edit,suggested_approve,suggested_reject"
    expression: "this.domain != 7 && this.action in(1,4,5,6,7,8)"
  };
}

message ACL {
  // Types of Policies for the ACL
  message Policy {
    // Policy for altering the membership of a role or perms of a role
    message Permission {
      bool view = 1;
      bool create = 2;
      bool edit = 3;
      bool delete = 4;
    }

    // Policy for altering the object
    message Object {
      bool view = 1;
      bool create = 2;
      bool delete = 3;
      bool view_history = 4;
      bool hidden_tx = 5;
    }

    // Policy for altering the object
    message ObjectField {
      bool view = 1;
      bool edit = 2;
      bool suggest_edit = 3;
      bool suggest_approve = 4;
      bool suggest_reject = 5;
    }
  }

  // This message is the tree node for operations on the state object
  message PathPermission {
    // The path is a sub path of a field mask
    string path = 1 [(buf.validate.field).string.min_len = 1];

    bool allow_sub_paths = 2;
    // The key is a valid sub path in the type of state object
    map<string, PathPermission> sub_paths = 3;

    // The Key must be a valid role id defined in the roles map


    // If the policy is not set than use a parent policy unless nested policy is set
    Policy.ObjectField policy = 4 [(buf.validate.field).required = true];

    option (buf.validate.message).cel = {
      id: "SubPathsAllowed"
      message: "Sub Paths are not allowed"
      expression: "!this.allow_sub_paths && this.sub_paths.size() > 0"
    };
  }

  message Entry {

    Policy.Permission memberships = 1 [(buf.validate.field).required = true];
    Policy.Permission role_permissions = 2 [(buf.validate.field).required = true];
    Policy.Permission role_defs = 3 [(buf.validate.field).required = true];

    Policy.Object object = 4 [(buf.validate.field).required = true];
    PathPermission object_paths = 5 [(buf.validate.field).required = true];

    google.protobuf.FieldMask view_mask = 6 [(buf.validate.field).required = true];
  }


  // The string is the stringified Identifier
  map<string, Entry> entries = 1 [(buf.validate.field).required = true];

  // The default is the base permissions for all users
  Entry default = 2 [(buf.validate.field).required = true];

  // The public is the base permissions unregistered users. Manly for viewing
  Entry public = 3 [(buf.validate.field).required = true];

}


message Collection {
  option (hlf.key_schema).namespace = "collection";
  option (hlf.key_schema).key_paths = {
    paths: ["id.collection_id"]
  };

  enum AuthType {
    AUTH_TYPE_UNSPECIFIED = 0;

    // Role based access control:
    // 1. Valid Roles are defined in the roles list
    // 2. Roles are assigned to users in the memberships map
    // 3. Permissions are stored in the Collections ACL with the role id as the key
    AUTH_TYPE_RBAC = 1;

    // Attribute based access control:
    // 1. Valid Attribute definitions are defined in the attributes list
    // 2. Attributes are stored in the users x509 certificate
    // 3. Permissions are stored in the Collections ACL with the user id as the key
    AUTH_TYPE_ABAC = 2;

    // Identity based access control:
    // 1. Valid Identities are users registered in the smart contract
    // 2. Permissions are stored in the Collections ACL with the user id as the key
    AUTH_TYPE_IDENTITY = 3;
  }


  message IdentifierEntry {
    Identifier identifier = 1 [(buf.validate.field).required = true];

    // The parent attribute that this attribute is derived from
    // If this is set, then it means that it should look in the permissions of
    // the parent attribute to if the user doesn't have a defined permission
    // for this attribute. Only if a non-root permission is not defined for the
    // the attribute will it look back to the parent attribute for a permissions.
    // This allows for a hierarchy of attributes to be defined
    repeated string parents = 2;
  }


  message Settings {

    // The type of authentication to use for this collection
    AuthType auth_type = 1;

    // If true, then the ACL will be used to restrict the view of the object
    // to only those users who have been granted access to that level of the object
    // This means that for listing objects, a filter will have to be applied
    // to each object. For list all objects, this will be a very expensive operation
    // as it will require walking multiple collections paths
    bool view_restrictions_enabled = 2;

    bool acl_inheritance_enabled   = 3;
  }


  message Id {
    string collection_id = 1 [(buf.validate.field).string.min_len = 1];
  }


  // The key for the ledger
  Id id = 1;
  Settings settings = 2;

  // The full type of object that this collection will store
  string object_type = 3 [(buf.validate.field).required = true];

  // The namespace of the object that this collection will store
  string object_namespace = 4;


  // The namespace of the object

  ACL acl = 5;

  // The key is the stringified Identifier
  // The value is the IdentifierEntry, which contains the Identifier and the parents
  // The parents are the attributes that this attribute is derived from
  map<string, IdentifierEntry> identifiers = 6;


}


message User {
  option (hlf.key_schema).namespace = "users";
  option (hlf.key_schema).key_paths = {
    paths: [
      "id.msp_id",
      "id.id"
    ]
  };

  // The key for the ledger
  message Id {
    string msp_id = 1 [(buf.validate.field).string.min_len = 1];
    string id = 2 [(buf.validate.field).string.min_len = 1];
  }

  Id id = 1 [(buf.validate.field).required = true];
  string name = 2 [(buf.validate.field).string.min_len = 1];


  // Memberships stores the roles that the user has in each collection
  // Key is the collection id
  // Value is the role id
  map<string, string> memberships = 3;

}
