// Code generated by protoc-gen-go-hlf. DO NOT EDIT.
// versions:
// - protoc-gen-cckey v0.0.1
// source: saacs/common/v0/suggestion.proto

package v0

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoregistry "google.golang.org/protobuf/reflect/protoregistry"
	fieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"
	strings "strings"
)

// ──────────────────────────────────────────────────
// saacs.common.v0.Suggestion
// Sub Item

func (m *Suggestion) SetKey(key *ItemKey) {
	m.PrimaryKey = key
	return
}

func (m *Suggestion) SetKeyAttr(attr []string) int {

	type ItemInterface interface {
		KeySchema() *KeySchema
	}

	if m.PrimaryKey == nil {
		m.PrimaryKey = &ItemKey{}
	}

	name := protoreflect.FullName(m.GetPrimaryKey().GetItemType())

	t, err := protoregistry.GlobalTypes.FindMessageByName(name)
	if err != nil {
		panic(err)
	}

	item, ok := t.New().Interface().(ItemInterface)
	if !ok {
		panic("Failed to cast to item interface")
	}

	primarySchema := item.KeySchema()
	if primarySchema == nil {
		panic("Primary schema is nil")
	}

	primaryAttrCount := len(primarySchema.GetProperties().GetPaths())

	// just set the primary key attributes
	if len(attr) <= primaryAttrCount {
		m.GetPrimaryKey().ItemKeyParts = attr
		return len(attr) - primaryAttrCount
	}

	remaining := len(attr) - primaryAttrCount

	if remaining <= 0 {
		panic("There was a issue with the number of the attributes")
	}

	attr = attr[remaining:]

	if len(attr) > 0 {
		m.SuggestionId = attr[0]
	} else {
		return 0
	}
	return len(attr) - 1
}

func (m *Suggestion) ItemKey() *ItemKey {

	key := &ItemKey{
		CollectionId: m.GetPrimaryKey().GetCollectionId(),
		ItemKind:     ItemKind_ITEM_KIND_SUB_ITEM,
		ItemType:     "saacs.common.v0.Suggestion",
		ItemKeyParts: []string{
			m.GetPrimaryKey().GetItemType(),
		},
	}

	key.ItemKeyParts = append(key.ItemKeyParts, m.GetPrimaryKey().GetItemKeyParts()...)
	key.ItemKeyParts = append(key.ItemKeyParts, m.KeyAttr()...)
	return key
}

func (m *Suggestion) KeyAttr() []string {
	attr := []string{}

	attr = append(attr, m.GetSuggestionId())
	return attr
}

func (m *Suggestion) ItemKind() ItemKind {
	return ItemKind_ITEM_KIND_SUB_ITEM
}

func (m *Suggestion) ItemType() string {
	return "saacs.common.v0.Suggestion"
}

func (m *Suggestion) KeySchema() *KeySchema {
	return &KeySchema{
		ItemKind:   ItemKind_ITEM_KIND_SUB_ITEM,
		Properties: &fieldmaskpb.FieldMask{Paths: []string{"suggestion_id"}},
	}
}

// NewFromKey - Creates a new item from a key
func (m *Suggestion) NewFromKey(key *ItemKey) *Suggestion {
	item := &Suggestion{}
	item.SetKey(key)

	return item
}

// StateKey - Returns a composite key for the state
// This follows the same structure as the saacs-cc stub library,
// Main difference is that it doesn't check the key for invalid characters
//
// Example key:= "\u0000auth.Collection\u0000collection0\u0000collection0\u0000"

func (m *Suggestion) StateKey() string {

	const sep = string(rune(0))

	attrs := m.ItemKey().GetItemKeyParts()
	if attrs == nil {
		panic("ItemKeyParts is nil")
	}

	collectionId := m.ItemKey().GetCollectionId()
	if collectionId == "" {
		panic("CollectionId is nil")
	}

	if len(attrs) == 0 {
		k := sep + "saacs.common.v0.Suggestion" + sep + collectionId + sep
		return k
	}
	k := sep + "saacs.common.v0.Suggestion" + sep + collectionId + sep + strings.Join(attrs, sep) + sep

	return k
}
