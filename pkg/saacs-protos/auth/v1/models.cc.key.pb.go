// Code generated by protoc-gen-go-hlf. DO NOT EDIT.
// versions:
// - protoc-gen-cckey v0.0.1
// source: auth/v1/models.proto

package v1

import (
	v1 "github.com/nova38/saacs/pkg/saacs-protos/auth/v1"
	fieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"
	strings "strings"
)

// ──────────────────────────────────────────────────
// auth.UserDirectMembership
// Primary Item

// Domain Item
func (m *UserDirectMembership) SetKey(key *v1.ItemKey) {
	m.SetKeyAttr(key.ItemKeyParts)
	m.CollectionId = key.GetCollectionId()
	return
}

// SetKeyAttr - Sets the key attributes, returns the number of extra attributes
func (m *UserDirectMembership) SetKeyAttr(attr []string) int {
	if len(attr) > 0 {
		m.MspId = attr[0]
	} else {
		return 0
	}
	if len(attr) > 1 {
		m.UserId = attr[1]
	} else {
		return 0
	}
	return len(attr) - 2
}

func (m *UserDirectMembership) ItemKey() *v1.ItemKey {
	key := &v1.ItemKey{
		CollectionId: m.GetCollectionId(),
		ItemKind:     2,
		ItemType:     "auth.UserDirectMembership",
		ItemKeyParts: m.KeyAttr(),
	}
	return key
}

func (m *UserDirectMembership) KeyAttr() []string {
	attr := []string{}
	attr = append(attr, m.GetMspId())
	attr = append(attr, m.GetUserId())
	return attr
}

func (m *UserDirectMembership) ItemKind() v1.ItemKind {
	return v1.ItemKind_ITEM_KIND_PRIMARY_ITEM
}

func (m *UserDirectMembership) ItemType() string {
	return "auth.UserDirectMembership"
}

func (m *UserDirectMembership) KeySchema() *v1.KeySchema {
	return &v1.KeySchema{
		ItemKind: v1.ItemKind_ITEM_KIND_PRIMARY_ITEM,
		Properties: &fieldmaskpb.FieldMask{Paths: []string{
			"msp_id",
			"user_id",
		}},
	}
}

// NewFromKey - Creates a new item from a key
func (m *UserDirectMembership) NewFromKey(key *v1.ItemKey) *UserDirectMembership {
	item := &UserDirectMembership{}
	item.SetKey(key)

	return item
}

// StateKey - Returns a composite key for the state
// This follows the same structure as the saacs-cc stub library,
// Main difference is that it doesn't check the key for invalid characters
//
// Example key:= "\u0000auth.Collection\u0000collection0\u0000collection0\u0000"

func (m *UserDirectMembership) StateKey() string {

	const sep = string(rune(0))

	attrs := m.ItemKey().GetItemKeyParts()
	if attrs == nil {
		panic("ItemKeyParts is nil")
	}

	collectionId := m.ItemKey().GetCollectionId()
	if collectionId == "" {
		panic("CollectionId is nil")
	}

	if len(attrs) == 0 {
		k := sep + "auth.UserDirectMembership" + sep + collectionId + sep
		return k
	}
	k := sep + "auth.UserDirectMembership" + sep + collectionId + sep + strings.Join(attrs, sep) + sep

	return k
}

// ──────────────────────────────────────────────────
// auth.Role
// Primary Item

// Domain Item
func (m *Role) SetKey(key *v1.ItemKey) {
	m.SetKeyAttr(key.ItemKeyParts)
	m.CollectionId = key.GetCollectionId()
	return
}

// SetKeyAttr - Sets the key attributes, returns the number of extra attributes
func (m *Role) SetKeyAttr(attr []string) int {
	if len(attr) > 0 {
		m.RoleId = attr[0]
	} else {
		return 0
	}
	return len(attr) - 1
}

func (m *Role) ItemKey() *v1.ItemKey {
	key := &v1.ItemKey{
		CollectionId: m.GetCollectionId(),
		ItemKind:     2,
		ItemType:     "auth.Role",
		ItemKeyParts: m.KeyAttr(),
	}
	return key
}

func (m *Role) KeyAttr() []string {
	attr := []string{}
	attr = append(attr, m.GetRoleId())
	return attr
}

func (m *Role) ItemKind() v1.ItemKind {
	return v1.ItemKind_ITEM_KIND_PRIMARY_ITEM
}

func (m *Role) ItemType() string {
	return "auth.Role"
}

func (m *Role) KeySchema() *v1.KeySchema {
	return &v1.KeySchema{
		ItemKind:   v1.ItemKind_ITEM_KIND_PRIMARY_ITEM,
		Properties: &fieldmaskpb.FieldMask{Paths: []string{"role_id"}},
	}
}

// NewFromKey - Creates a new item from a key
func (m *Role) NewFromKey(key *v1.ItemKey) *Role {
	item := &Role{}
	item.SetKey(key)

	return item
}

// StateKey - Returns a composite key for the state
// This follows the same structure as the saacs-cc stub library,
// Main difference is that it doesn't check the key for invalid characters
//
// Example key:= "\u0000auth.Collection\u0000collection0\u0000collection0\u0000"

func (m *Role) StateKey() string {

	const sep = string(rune(0))

	attrs := m.ItemKey().GetItemKeyParts()
	if attrs == nil {
		panic("ItemKeyParts is nil")
	}

	collectionId := m.ItemKey().GetCollectionId()
	if collectionId == "" {
		panic("CollectionId is nil")
	}

	if len(attrs) == 0 {
		k := sep + "auth.Role" + sep + collectionId + sep
		return k
	}
	k := sep + "auth.Role" + sep + collectionId + sep + strings.Join(attrs, sep) + sep

	return k
}

// ──────────────────────────────────────────────────
// auth.UserCollectionRoles
// Primary Item

// Domain Item
func (m *UserCollectionRoles) SetKey(key *v1.ItemKey) {
	m.SetKeyAttr(key.ItemKeyParts)
	m.CollectionId = key.GetCollectionId()
	return
}

// SetKeyAttr - Sets the key attributes, returns the number of extra attributes
func (m *UserCollectionRoles) SetKeyAttr(attr []string) int {
	if len(attr) > 0 {
		m.MspId = attr[0]
	} else {
		return 0
	}
	if len(attr) > 1 {
		m.UserId = attr[1]
	} else {
		return 0
	}
	return len(attr) - 2
}

func (m *UserCollectionRoles) ItemKey() *v1.ItemKey {
	key := &v1.ItemKey{
		CollectionId: m.GetCollectionId(),
		ItemKind:     2,
		ItemType:     "auth.UserCollectionRoles",
		ItemKeyParts: m.KeyAttr(),
	}
	return key
}

func (m *UserCollectionRoles) KeyAttr() []string {
	attr := []string{}
	attr = append(attr, m.GetMspId())
	attr = append(attr, m.GetUserId())
	return attr
}

func (m *UserCollectionRoles) ItemKind() v1.ItemKind {
	return v1.ItemKind_ITEM_KIND_PRIMARY_ITEM
}

func (m *UserCollectionRoles) ItemType() string {
	return "auth.UserCollectionRoles"
}

func (m *UserCollectionRoles) KeySchema() *v1.KeySchema {
	return &v1.KeySchema{
		ItemKind: v1.ItemKind_ITEM_KIND_PRIMARY_ITEM,
		Properties: &fieldmaskpb.FieldMask{Paths: []string{
			"msp_id",
			"user_id",
		}},
	}
}

// NewFromKey - Creates a new item from a key
func (m *UserCollectionRoles) NewFromKey(key *v1.ItemKey) *UserCollectionRoles {
	item := &UserCollectionRoles{}
	item.SetKey(key)

	return item
}

// StateKey - Returns a composite key for the state
// This follows the same structure as the saacs-cc stub library,
// Main difference is that it doesn't check the key for invalid characters
//
// Example key:= "\u0000auth.Collection\u0000collection0\u0000collection0\u0000"

func (m *UserCollectionRoles) StateKey() string {

	const sep = string(rune(0))

	attrs := m.ItemKey().GetItemKeyParts()
	if attrs == nil {
		panic("ItemKeyParts is nil")
	}

	collectionId := m.ItemKey().GetCollectionId()
	if collectionId == "" {
		panic("CollectionId is nil")
	}

	if len(attrs) == 0 {
		k := sep + "auth.UserCollectionRoles" + sep + collectionId + sep
		return k
	}
	k := sep + "auth.UserCollectionRoles" + sep + collectionId + sep + strings.Join(attrs, sep) + sep

	return k
}

// ──────────────────────────────────────────────────
// auth.UserEmbeddedRoles
// Primary Item

// Domain Item
func (m *UserEmbeddedRoles) SetKey(key *v1.ItemKey) {
	m.SetKeyAttr(key.ItemKeyParts)
	m.CollectionId = key.GetCollectionId()
	return
}

// SetKeyAttr - Sets the key attributes, returns the number of extra attributes
func (m *UserEmbeddedRoles) SetKeyAttr(attr []string) int {
	if len(attr) > 0 {
		m.MspId = attr[0]
	} else {
		return 0
	}
	if len(attr) > 1 {
		m.UserId = attr[1]
	} else {
		return 0
	}
	return len(attr) - 2
}

func (m *UserEmbeddedRoles) ItemKey() *v1.ItemKey {
	key := &v1.ItemKey{
		CollectionId: m.GetCollectionId(),
		ItemKind:     2,
		ItemType:     "auth.UserEmbeddedRoles",
		ItemKeyParts: m.KeyAttr(),
	}
	return key
}

func (m *UserEmbeddedRoles) KeyAttr() []string {
	attr := []string{}
	attr = append(attr, m.GetMspId())
	attr = append(attr, m.GetUserId())
	return attr
}

func (m *UserEmbeddedRoles) ItemKind() v1.ItemKind {
	return v1.ItemKind_ITEM_KIND_PRIMARY_ITEM
}

func (m *UserEmbeddedRoles) ItemType() string {
	return "auth.UserEmbeddedRoles"
}

func (m *UserEmbeddedRoles) KeySchema() *v1.KeySchema {
	return &v1.KeySchema{
		ItemKind: v1.ItemKind_ITEM_KIND_PRIMARY_ITEM,
		Properties: &fieldmaskpb.FieldMask{Paths: []string{
			"msp_id",
			"user_id",
		}},
	}
}

// NewFromKey - Creates a new item from a key
func (m *UserEmbeddedRoles) NewFromKey(key *v1.ItemKey) *UserEmbeddedRoles {
	item := &UserEmbeddedRoles{}
	item.SetKey(key)

	return item
}

// StateKey - Returns a composite key for the state
// This follows the same structure as the saacs-cc stub library,
// Main difference is that it doesn't check the key for invalid characters
//
// Example key:= "\u0000auth.Collection\u0000collection0\u0000collection0\u0000"

func (m *UserEmbeddedRoles) StateKey() string {

	const sep = string(rune(0))

	attrs := m.ItemKey().GetItemKeyParts()
	if attrs == nil {
		panic("ItemKeyParts is nil")
	}

	collectionId := m.ItemKey().GetCollectionId()
	if collectionId == "" {
		panic("CollectionId is nil")
	}

	if len(attrs) == 0 {
		k := sep + "auth.UserEmbeddedRoles" + sep + collectionId + sep
		return k
	}
	k := sep + "auth.UserEmbeddedRoles" + sep + collectionId + sep + strings.Join(attrs, sep) + sep

	return k
}

// Invalid Key Schema
// paths:"msp_id"  paths:"oidvalue"
