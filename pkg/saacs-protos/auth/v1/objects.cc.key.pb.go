// Code generated by protoc-gen-go-hlf. DO NOT EDIT.
// versions:
// - protoc-gen-cckey v0.0.1
// source: auth/v1/objects.proto

package v1

import (
	v1 "github.com/nova38/saacs/pkg/saacs-protos/auth/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoregistry "google.golang.org/protobuf/reflect/protoregistry"
	fieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"
	strings "strings"
)

// ──────────────────────────────────────────────────
// auth.Collection
// Primary Item

// Domain Item
func (m *Collection) SetKey(key *v1.ItemKey) {
	m.SetKeyAttr(key.ItemKeyParts)
	m.CollectionId = key.GetCollectionId()
	return
}

// SetKeyAttr - Sets the key attributes, returns the number of extra attributes
func (m *Collection) SetKeyAttr(attr []string) int {
	if len(attr) > 0 {
		m.CollectionId = attr[0]
	} else {
		return 0
	}
	return len(attr) - 1
}

func (m *Collection) ItemKey() *v1.ItemKey {
	key := &v1.ItemKey{
		CollectionId: m.GetCollectionId(),
		ItemKind:     2,
		ItemType:     "auth.Collection",
		ItemKeyParts: m.KeyAttr(),
	}
	return key
}

func (m *Collection) KeyAttr() []string {
	attr := []string{}
	attr = append(attr, m.GetCollectionId())
	return attr
}

func (m *Collection) ItemKind() v1.ItemKind {
	return v1.ItemKind_ITEM_KIND_PRIMARY_ITEM
}

func (m *Collection) ItemType() string {
	return "auth.Collection"
}

func (m *Collection) KeySchema() *v1.KeySchema {
	return &v1.KeySchema{
		ItemKind:   v1.ItemKind_ITEM_KIND_PRIMARY_ITEM,
		Properties: &fieldmaskpb.FieldMask{Paths: []string{"collection_id"}},
	}
}

// NewFromKey - Creates a new item from a key
func (m *Collection) NewFromKey(key *v1.ItemKey) *Collection {
	item := &Collection{}
	item.SetKey(key)

	return item
}

// StateKey - Returns a composite key for the state
// This follows the same structure as the saacs-cc stub library,
// Main difference is that it doesn't check the key for invalid characters
//
// Example key:= "\u0000auth.Collection\u0000collection0\u0000collection0\u0000"

func (m *Collection) StateKey() string {

	const sep = string(rune(0))

	attrs := m.ItemKey().GetItemKeyParts()
	if attrs == nil {
		panic("ItemKeyParts is nil")
	}

	collectionId := m.ItemKey().GetCollectionId()
	if collectionId == "" {
		panic("CollectionId is nil")
	}

	if len(attrs) == 0 {
		k := sep + "auth.Collection" + sep + collectionId + sep
		return k
	}
	k := sep + "auth.Collection" + sep + collectionId + sep + strings.Join(attrs, sep) + sep

	return k
}

// ──────────────────────────────────────────────────
// auth.Suggestion
// Sub Item

func (m *Suggestion) SetKey(key *v1.ItemKey) {
	m.PrimaryKey = key
	return
}

func (m *Suggestion) SetKeyAttr(attr []string) int {

	type ItemInterface interface {
		KeySchema() *v1.KeySchema
	}

	if m.PrimaryKey == nil {
		m.PrimaryKey = &v1.ItemKey{}
	}

	name := protoreflect.FullName(m.GetPrimaryKey().GetItemType())

	t, err := protoregistry.GlobalTypes.FindMessageByName(name)
	if err != nil {
		panic(err)
	}

	item, ok := t.New().Interface().(ItemInterface)
	if !ok {
		panic("Failed to cast to item interface")
	}

	primarySchema := item.KeySchema()
	if primarySchema == nil {
		panic("Primary schema is nil")
	}

	primaryAttrCount := len(primarySchema.GetProperties().GetPaths())

	// just set the primary key attributes
	if len(attr) <= primaryAttrCount {
		m.GetPrimaryKey().ItemKeyParts = attr
		return len(attr) - primaryAttrCount
	}

	remaining := len(attr) - primaryAttrCount

	if remaining <= 0 {
		panic("There was a issue with the number of the attributes")
	}

	attr = attr[remaining:]

	if len(attr) > 0 {
		m.SuggestionId = attr[0]
	} else {
		return 0
	}
	return len(attr) - 1
}

func (m *Suggestion) ItemKey() *v1.ItemKey {

	key := &v1.ItemKey{
		CollectionId: m.GetPrimaryKey().GetCollectionId(),
		ItemKind:     v1.ItemKind_ITEM_KIND_SUB_ITEM,
		ItemType:     "auth.Suggestion",
		ItemKeyParts: []string{
			m.GetPrimaryKey().GetItemType(),
		},
	}

	key.ItemKeyParts = append(key.ItemKeyParts, m.GetPrimaryKey().GetItemKeyParts()...)
	key.ItemKeyParts = append(key.ItemKeyParts, m.KeyAttr()...)
	return key
}

func (m *Suggestion) KeyAttr() []string {
	attr := []string{}

	attr = append(attr, m.GetSuggestionId())
	return attr
}

func (m *Suggestion) ItemKind() v1.ItemKind {
	return v1.ItemKind_ITEM_KIND_SUB_ITEM
}

func (m *Suggestion) ItemType() string {
	return "auth.Suggestion"
}

func (m *Suggestion) KeySchema() *v1.KeySchema {
	return &v1.KeySchema{
		ItemKind:   v1.ItemKind_ITEM_KIND_SUB_ITEM,
		Properties: &fieldmaskpb.FieldMask{Paths: []string{"suggestion_id"}},
	}
}

// NewFromKey - Creates a new item from a key
func (m *Suggestion) NewFromKey(key *v1.ItemKey) *Suggestion {
	item := &Suggestion{}
	item.SetKey(key)

	return item
}

// StateKey - Returns a composite key for the state
// This follows the same structure as the saacs-cc stub library,
// Main difference is that it doesn't check the key for invalid characters
//
// Example key:= "\u0000auth.Collection\u0000collection0\u0000collection0\u0000"

func (m *Suggestion) StateKey() string {

	const sep = string(rune(0))

	attrs := m.ItemKey().GetItemKeyParts()
	if attrs == nil {
		panic("ItemKeyParts is nil")
	}

	collectionId := m.ItemKey().GetCollectionId()
	if collectionId == "" {
		panic("CollectionId is nil")
	}

	if len(attrs) == 0 {
		k := sep + "auth.Suggestion" + sep + collectionId + sep
		return k
	}
	k := sep + "auth.Suggestion" + sep + collectionId + sep + strings.Join(attrs, sep) + sep

	return k
}

// ──────────────────────────────────────────────────
// auth.HiddenTxList
// Sub Item

func (m *HiddenTxList) SetKey(key *v1.ItemKey) {
	m.PrimaryKey = key
	return
}

func (m *HiddenTxList) SetKeyAttr(attr []string) int {

	type ItemInterface interface {
		KeySchema() *v1.KeySchema
	}

	if m.PrimaryKey == nil {
		m.PrimaryKey = &v1.ItemKey{}
	}

	name := protoreflect.FullName(m.GetPrimaryKey().GetItemType())

	t, err := protoregistry.GlobalTypes.FindMessageByName(name)
	if err != nil {
		panic(err)
	}

	item, ok := t.New().Interface().(ItemInterface)
	if !ok {
		panic("Failed to cast to item interface")
	}

	primarySchema := item.KeySchema()
	if primarySchema == nil {
		panic("Primary schema is nil")
	}

	primaryAttrCount := len(primarySchema.GetProperties().GetPaths())

	// just set the primary key attributes
	if len(attr) <= primaryAttrCount {
		m.GetPrimaryKey().ItemKeyParts = attr
		return len(attr) - primaryAttrCount
	}

	remaining := len(attr) - primaryAttrCount

	if remaining <= 0 {
		panic("There was a issue with the number of the attributes")
	}

	attr = attr[remaining:]

	return len(attr) - 0
}

func (m *HiddenTxList) ItemKey() *v1.ItemKey {

	key := &v1.ItemKey{
		CollectionId: m.GetPrimaryKey().GetCollectionId(),
		ItemKind:     v1.ItemKind_ITEM_KIND_SUB_ITEM,
		ItemType:     "auth.HiddenTxList",
		ItemKeyParts: []string{
			m.GetPrimaryKey().GetItemType(),
		},
	}

	key.ItemKeyParts = append(key.ItemKeyParts, m.GetPrimaryKey().GetItemKeyParts()...)
	key.ItemKeyParts = append(key.ItemKeyParts, m.KeyAttr()...)
	return key
}

func (m *HiddenTxList) KeyAttr() []string {
	attr := []string{}

	return attr
}

func (m *HiddenTxList) ItemKind() v1.ItemKind {
	return v1.ItemKind_ITEM_KIND_SUB_ITEM
}

func (m *HiddenTxList) ItemType() string {
	return "auth.HiddenTxList"
}

func (m *HiddenTxList) KeySchema() *v1.KeySchema {
	return &v1.KeySchema{
		ItemKind: v1.ItemKind_ITEM_KIND_SUB_ITEM,
	}
}

// NewFromKey - Creates a new item from a key
func (m *HiddenTxList) NewFromKey(key *v1.ItemKey) *HiddenTxList {
	item := &HiddenTxList{}
	item.SetKey(key)

	return item
}

// StateKey - Returns a composite key for the state
// This follows the same structure as the saacs-cc stub library,
// Main difference is that it doesn't check the key for invalid characters
//
// Example key:= "\u0000auth.Collection\u0000collection0\u0000collection0\u0000"

func (m *HiddenTxList) StateKey() string {

	const sep = string(rune(0))

	attrs := m.ItemKey().GetItemKeyParts()
	if attrs == nil {
		panic("ItemKeyParts is nil")
	}

	collectionId := m.ItemKey().GetCollectionId()
	if collectionId == "" {
		panic("CollectionId is nil")
	}

	if len(attrs) == 0 {
		k := sep + "auth.HiddenTxList" + sep + collectionId + sep
		return k
	}
	k := sep + "auth.HiddenTxList" + sep + collectionId + sep + strings.Join(attrs, sep) + sep

	return k
}
